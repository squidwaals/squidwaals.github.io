<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Learning on Squid&#39;s Home</title>
        <link>http://localhost:1313/categories/learning/</link>
        <description>Recent content in Learning on Squid&#39;s Home</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>Squid Wu</copyright><atom:link href="http://localhost:1313/categories/learning/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Resultants Basics</title>
        <link>http://localhost:1313/slices/resultants-basics/</link>
        <pubDate>Sun, 17 Aug 2025 18:12:59 +0800</pubDate>
        
        <guid>http://localhost:1313/slices/resultants-basics/</guid>
        <description>&lt;p&gt;之前了解到和结式相关的一些内容，感觉挺神奇的，跟着ai快速学习了一下，也稍微翻了翻范德瓦尔登的代数学，记录一下。&lt;/p&gt;
&lt;h2 id=&#34;sylvester行列式&#34;&gt;Sylvester行列式
&lt;/h2&gt;&lt;p&gt;在代数学中，结式（Resultant） 是一个用于研究多项式方程组解的重要工具，主要用于判断两个多项式是否有公共根。&lt;/p&gt;
&lt;p&gt;设两个一元多项式：&lt;/p&gt;
&lt;p&gt;$
f(x) = a_n x^n + a_{n-1} x^{n-1} + \dots + a_0 \quad (a_n \neq 0)
$&lt;/p&gt;
&lt;p&gt;$
g(x) = b_m x^m + b_{m-1} x^{m-1} + \dots + b_0 \quad (b_m \neq 0)
$&lt;/p&gt;
&lt;p&gt;它们的结式是一个由系数 $a_i, b_j$ 构成的行列式（Sylvester行列式），记为 $\text{Res}(f, g)$。其构造规则为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;行列式共有 $n + m$ 行，前 $m$ 行由 $f(x)$ 的系数（从 $a_n$ 到 $a_0$）重复排列，每行向右移一位（空位补0）；&lt;/li&gt;
&lt;li&gt;后 $n$ 行由 $g(x)$ 的系数（从 $b_m$ 到 $b_0$）重复排列，同样每行向右移一位（空位补0）。&lt;/li&gt;
&lt;/ul&gt;
$$
\text{Res}(f,g) = 
\begin{vmatrix}
a_n &amp; a_{n-1} &amp; \cdots &amp; a_0 &amp; 0 &amp; \cdots &amp; \cdots &amp; 0 \\
0 &amp; a_n &amp; a_{n-1} &amp; \cdots &amp; a_0 &amp; \cdots &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; \cdots &amp; a_n &amp; a_{n-1} &amp; \cdots &amp; \cdots &amp; a_0 \\
b_m&amp; b_{m-1} &amp; \cdots &amp; b_1 &amp; b_0 &amp; \cdots &amp; \cdots &amp; 0 \\
0 &amp; b_m &amp; b_{m-1} &amp; \cdots &amp; b_1 &amp; \cdots &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; \cdots &amp; b_m &amp; b_{m-1} &amp; \cdots &amp; b_1 &amp; b_0\\
\end{vmatrix}
$$&lt;h2 id=&#34;多项式公共根&#34;&gt;多项式公共根
&lt;/h2&gt;&lt;p&gt;两个多项式 $f(x)$ 和 $g(x)$ 有公共根的充要条件是它们的结式为0，即 $\text{Res}(f, g) = 0$。&lt;/p&gt;
&lt;p&gt;证明核心思路:
结式为零等价于“存在非零多项式 $u(x), v(x)$ 使得 $u(x)f(x) = v(x)g(x)$，且 $\deg u &amp;lt; m，\deg v &amp;lt; n$”，而这又等价于 $f$ 和 $g$ 有公共因子。&lt;/p&gt;
&lt;h3 id=&#34;步骤1结式为零--存在非零多项式-u-v-满足-uf--vg&#34;&gt;步骤1：结式为零 ⇨ 存在非零多项式 $u, v$ 满足 $uf = vg$
&lt;/h3&gt;&lt;p&gt;结式 $\text{Res}(f, g)$ 是某线性方程组系数矩阵的行列式。具体来说，考虑以下方程：&lt;/p&gt;
$$ u(x)f(x) = v(x)g(x), $$&lt;p&gt;其中 $ u(x) = c_{m-1}x^{m-1} + \dots + c_0，v(x) = -d_{n-1}x^{n-1} - \dots - d_0 $。&lt;/p&gt;
&lt;p&gt;两边展开后，同次幂的系数必须相等。对于 $x^k (k = 0, 1, \dots, n+m-1)$，系数等式构成一个线性方程组，&lt;/p&gt;
$$
\begin{cases}
c_{m-1} a_n  + d_{n-1} b_m &amp;= 0 \\
c_{m-1} a_{n-1}  + c_{m-2} a_n + d_{n-2} b_{m-1} + d_{n-1} b_m &amp;= 0 \\
\vdots \\
c_0 a_0 + d_0 b_0 &amp;=0 \\
\end{cases}
$$&lt;p&gt;其系数矩阵正是结式的行列式对应矩阵的转置。&lt;/p&gt;
&lt;p&gt;若 $\text{Res}(f, g) = 0$，则该线性方程组有非零解 $(c_{m-1}, \dots, c_{0}, d_{n-1}, \dots, d_{0})$，即存在非零多项式 $u, v$ 使得 $uf = vg$。&lt;/p&gt;
&lt;h3 id=&#34;步骤2存在非零-u-v-满足-uf--vg--f-g-有公共因子&#34;&gt;步骤2：存在非零 $u, v$ 满足 $uf = vg$ ⇨ $f, g$ 有公共因子
&lt;/h3&gt;&lt;p&gt;假设 $uf = vg$，其中 $u \neq 0，v \neq 0$，且 $\deg u &amp;lt; m，\deg v &amp;lt; n$。&lt;/p&gt;
&lt;p&gt;由于 $f$ 和 $g$ 非零，可设它们的最大公因子为 $d(x)$，即 $f = d \cdot f_1，g = d \cdot g_1$，其中 $\gcd(f_1, g_1) = 1$（互素）。&lt;/p&gt;
&lt;p&gt;代入等式得 $u d f_1 = v d g_1$，约去 $d$ 后有 $u f_1 = v g_1$。因 $f_1$ 与 $g_1$ 互素，故 $f_1$ 必整除 $v$，$g_1$ 必整除 $u$。&lt;/p&gt;
&lt;p&gt;若 $d(x)$ 为常数（即 $f, g$ 互素），则 $f_1 = f，g_1 = g$，此时 $f$ 整除 $v$，$g$ 整除 $u$。但 $\deg v &amp;lt; n = \deg f$，$\deg u &amp;lt; m = \deg g$，故 $v$ 只能是零多项式，与 $v \neq 0$ 矛盾。&lt;/p&gt;
&lt;p&gt;因此，$d(x)$ 必为次数至少1的多项式，即 $f$ 和 $g$ 有非平凡公共因子。&lt;/p&gt;
&lt;h3 id=&#34;步骤3f-g-有公共因子--结式为零&#34;&gt;步骤3：$f, g$ 有公共因子 ⇨ 结式为零
&lt;/h3&gt;&lt;p&gt;若 $f$ 和 $g$ 有公共根 $\alpha$（或公共因子 $h(x) = (x - \alpha) \dots$），则 $f(\alpha) = 0$ 且 $g(\alpha) = 0$。&lt;/p&gt;
&lt;p&gt;考虑向量 $\boldsymbol{\alpha} = (\alpha^{n+m-1}, \alpha^{n+m-2}, \dots, \alpha, 1)^T$，代入结式的行列式矩阵 $M$ 中，可验证 $M \boldsymbol{\alpha} = \boldsymbol{0}$ ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前 m 行：$a_n \alpha^{n+m-k} + a_{n-1} \alpha^{n+m-k-1} + \dots + a_0 \alpha^{m-k} = \alpha^{m-k} f(\alpha) = 0$（k 为行索引）；&lt;/li&gt;
&lt;li&gt;后 n 行：$b_m \alpha^{2m+n-k} + b_m \alpha^{2m+n-k-1} + \dots + b_0 \alpha^{m+n-k} = \alpha^{m+n-k} g(\alpha) = 0$（k 为行索引）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，矩阵 $M$ 有非零解 $\boldsymbol{\alpha}$，行列式 $\text{Res}(f, g) = 0$。&lt;/p&gt;
&lt;p&gt;结式的这种和多项式公共根有关的性质可以用到解多项式方程组中。
比如在解二元多项式方程组 $f(x, y) = 0$ 和 $g(x, y) = 0$ 时，可将 $f, g$ 视为关于 $x$ 的多项式（视 $y$ 为常数），其结式 $\text{Res}_x(f, g)$ 是关于 $y$ 的多项式，该多项式的根即为方程组解中 $y$ 的可能值（消去了 $x$）。&lt;/p&gt;
&lt;h2 id=&#34;根表达式&#34;&gt;根表达式
&lt;/h2&gt;&lt;p&gt;有了多项式公共根的性质，可以证明结式有一个漂亮简洁的多项式根的表达式。&lt;/p&gt;
&lt;p&gt;设${\alpha_i}$是$f(x)$的根，${\beta_j}$是$g(x)$的根，$f(x)=a_n\prod_{i=1}^n(x-\alpha_i)$，$g(x)=b_m \prod_{j=1}^m (x-\beta_j)$，多项式系数${a_i},{b_i}$是根的多项式，从而结式是根的多项式函数。&lt;/p&gt;
&lt;p&gt;固定$f(x)$的 $n-1$ 个根不变，固定$g(x)$的 $m-1$ 个根不变，将剩下的 $\alpha_i$，$\beta_j$ 当作变量。由结式的公共根性质可知，当 $\alpha_i=\beta_j$ 的时候，$\text{Res}(f,g)=0$。又由于结式是根的多项式函数，所以&lt;/p&gt;
$$
\text{Res}(f,g)\propto (\alpha_i-\beta_j)^{p},p\geq 1 .
$$&lt;p&gt;这种性质对任意一对${\alpha_i,\beta_j}$均成立，所以&lt;/p&gt;
$$
\text{Res}(f,g)\propto \prod_{i=1}^n\prod_{j=1}^m (\alpha_i-\beta_j)^{p_{ij}},p_{ij}\geq 1 .
$$&lt;p&gt;注意到，对于任何根$\alpha_i,\beta_j$，多项式系数${a_i},{b_i}$是根的一次函数，从Sylvester行列式的表达式可以看出 $\text{Res}(f,g)$ 中 $\alpha_i$ 的最高次数是 $m$ 次，$\beta_j$ 的最高次数是 $n$ 次，所以 $p_{ij} = 1$。&lt;/p&gt;
&lt;p&gt;此外，由于 $a_n$ 是系数${a_i}$ 的公共因子，$b_m$ 是系数 ${b_j}$ 的公共因子，所以&lt;/p&gt;
$$
\text{Res}(f,g)\propto a_n^m b_m^n \prod_{i=1}^n\prod_{j=1}^m (\alpha_i-\beta_j).
$$&lt;p&gt;现在确定比例系数。考虑到 $b_0=b_m \prod_{j=1}^m (-\beta_j)$，从而上式右侧 $b_0$ 最高次项的系数为 $a_n^m$。而从Sylvester行列式看，$b_0$ 次数最高的行列式展开项就是沿着主对角线的乘积项，它的系数也是$a_n^m$。&lt;/p&gt;
&lt;p&gt;所以比例系数就等于1，结式可以写成&lt;/p&gt;
$$
\text{Res}(f, g) = a_n^m b_m^n \prod_{i=1}^n\prod_{j=1}^m (\alpha_i - \beta_j)= a_n^m \prod_{i=1}^n g(\alpha_i) = (-1)^{mn} \cdot b_m^n \prod_{j=1}^m f(\beta_j).
$$&lt;h2 id=&#34;乘法性质&#34;&gt;乘法性质
&lt;/h2&gt;&lt;p&gt;从结式的根表达式可以直接看出结式的乘法性质。&lt;/p&gt;
&lt;p&gt;设三个一元多项式：&lt;/p&gt;
&lt;p&gt;$
f(x) = a_n x^n + a_{n-1} x^{n-1} + \dots + a_0=a_n\prod_{i=1}^n (x-\alpha_i) \quad (a_n \neq 0)，
$&lt;/p&gt;
&lt;p&gt;$
g(x) = b_m x^m + b_{m-1} x^{m-1} + \dots + b_0=b_m\prod_{j=1}^m (x-\beta_j) \quad (b_m \neq 0)，
$&lt;/p&gt;
&lt;p&gt;$
h(x) = c_l x^l + c_{l-1} x^{l-1} + \dots + c_0=c_l\prod_{k=1}^l(x-\gamma_k) \quad (c_l \neq 0)，
$&lt;/p&gt;
&lt;p&gt;容易看出&lt;/p&gt;
$$
\begin{aligned}
\text{Res}(fg,h)&amp;= (a_n b_m)^l c_l^{m+n} \prod_{i=1}^{n}\prod_{k=1}^l (\alpha_i-\gamma_k) \prod_{j=1}^{m}\prod_{k=1}^l  (\beta_j - \gamma_k) \\
&amp;= \left(a_n^l c_l^n  \prod_{i=1}^{n}\prod_{k=1}^l (\alpha_i-\gamma_k)\right) \left( b_m^l c_l^m \prod_{j=1}^{m}\prod_{k=1}^l  (\beta_j - \gamma_k) \right) \\
&amp;= \text{Res}(f,h) \text{Res}(g,h)
\end{aligned},
$$$$
\begin{aligned}
\text{Res}(f,gh)&amp;= a_n^{m+l} {(b_m c_l)}^{n} \prod_{i=1}^{n}\prod_{j=1}^m (\alpha_i-\beta_j) \prod_{i=1}^{n}\prod_{k=1}^l  (\alpha_i - \gamma_k) \\
&amp;= \left(a_n^m b_m^n  \prod_{i=1}^{n}\prod_{j=1}^m (\alpha_i-\beta_j) \right) \left(a_n^l c_l^n \prod_{i=1}^{n}\prod_{k=1}^l  (\alpha_i - \gamma_k) \right)\\
&amp;= \text{Res}(f,g) \text{Res}(f,h)
\end{aligned}.
$$</description>
        </item>
        <item>
        <title>Companion Matrix</title>
        <link>http://localhost:1313/slices/companion-matrix/</link>
        <pubDate>Sat, 05 Jul 2025 13:14:24 +0800</pubDate>
        
        <guid>http://localhost:1313/slices/companion-matrix/</guid>
        <description>&lt;p&gt;最近了解到多项式友矩阵的相关内容，好像挺基础的，但之前不知道，所以记录一下。&lt;/p&gt;
&lt;h2 id=&#34;友矩阵&#34;&gt;友矩阵
&lt;/h2&gt;&lt;p&gt;友矩阵的定义是&lt;/p&gt;
$$
A=\left(
\begin{array}{c}
0 &amp; 0 &amp;\cdots &amp;0 &amp;0 &amp; -c_0 \\
1 &amp; 0 &amp;\cdots &amp;0 &amp;0 &amp; -c_1 \\
0 &amp; 1 &amp;\cdots &amp;0 &amp;0 &amp; -c_2 \\
\vdots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\vdots \\
0 &amp; 0 &amp;\cdots &amp;1 &amp;0 &amp; -c_{n-2}\\
0 &amp; 0 &amp;\cdots &amp;0 &amp;1 &amp; -c_{n-1}
\end{array}
\right)
$$&lt;p&gt;它的 $n$ 个特征值正好是多项式 $P(x)=x^n+c_{n-1}x^{n-1}+\cdots+c_0$ 的$n$个根。&lt;/p&gt;
&lt;h2 id=&#34;证明&#34;&gt;证明
&lt;/h2&gt;&lt;p&gt;可以计算矩阵 $A$ 的特征多项式直接证明&lt;/p&gt;
$$
\begin{aligned}
|\lambda I - A| &amp;=\left|
\begin{array}{c}
\lambda &amp; 0 &amp;\cdots &amp;0 &amp;0 &amp; c_0 \\
-1 &amp; \lambda &amp;\cdots &amp;0 &amp;0 &amp; c_1 \\
0 &amp; -1 &amp;\cdots &amp;0 &amp;0 &amp; c_2 \\
\vdots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\vdots \\
0 &amp; 0 &amp;\cdots &amp;-1 &amp;\lambda &amp; c_{n-2}\\
0 &amp; 0 &amp;\cdots &amp;0 &amp;-1 &amp; \lambda+c_{n-1}
\end{array}
\right|_n \\
&amp;= \lambda \left|
\begin{array}{c}
\lambda &amp; 0 &amp;\cdots &amp;0 &amp;0 &amp; c_1 \\
-1 &amp; \lambda &amp;\cdots &amp;0 &amp;0 &amp; c_2 \\
0 &amp; -1 &amp;\cdots &amp;0 &amp;0 &amp; c_3 \\
\vdots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\vdots \\
0 &amp; 0 &amp;\cdots &amp;-1 &amp;\lambda &amp; c_{n-2}\\
0 &amp; 0 &amp;\cdots &amp;0 &amp;-1 &amp; \lambda+c_{n-1}
\end{array}
\right|_{n-1}+(-1)^{n-1}c_0 \left|
\begin{array}{c}
-1 &amp; \lambda &amp;\cdots &amp;0 &amp;0  \\
0 &amp; -1 &amp;\cdots &amp;0 &amp;0 \\
\vdots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\vdots \\
0 &amp; 0 &amp;\cdots &amp;-1 &amp;\lambda \\
0 &amp; 0 &amp;\cdots &amp;0 &amp;-1 
\end{array}
\right|_{n-1} \\
&amp;= \lambda \left|
\begin{array}{c}
\lambda &amp; 0 &amp;\cdots &amp;0 &amp;0 &amp; c_1 \\
-1 &amp; \lambda &amp;\cdots &amp;0 &amp;0 &amp; c_2 \\
0 &amp; -1 &amp;\cdots &amp;0 &amp;0 &amp; c_3 \\
\vdots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\vdots \\
0 &amp; 0 &amp;\cdots &amp;-1 &amp;\lambda &amp; c_{n-2}\\
0 &amp; 0 &amp;\cdots &amp;0 &amp;-1 &amp; \lambda+c_{n-1}
\end{array}
\right|_{n-1}+c_0 \\
&amp;= \lambda^2 \left|
\begin{array}{c}
\lambda &amp; 0 &amp;\cdots &amp;0 &amp;0 &amp; c_2 \\
-1 &amp; \lambda &amp;\cdots &amp;0 &amp;0 &amp; c_3 \\
0 &amp; -1 &amp;\cdots &amp;0 &amp;0 &amp; c_4 \\
\vdots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\vdots \\
0 &amp; 0 &amp;\cdots &amp;-1 &amp;\lambda &amp; c_{n-2}\\
0 &amp; 0 &amp;\cdots &amp;0 &amp;-1 &amp; \lambda+c_{n-1}
\end{array}
\right|_{n-2}+\lambda c_1+c_0 \\
&amp;=\cdots \\
&amp;=\lambda^{n-1} |\lambda + c_{n-1}|_1 + \lambda^{n-2}c_{n-2}+\cdots+\lambda c_1+c_0 \\
&amp;=\lambda^n + \lambda^{n-1}c_{n-1}+\cdots+ \lambda c_1 + c_0
\end{aligned}
$$&lt;p&gt;可见矩阵 $A$ 的特征多项式正好就是 $P(x)=x^n+c_{n-1}x^{n-1}+\cdots+c_0$，所以它的 $n$ 个特征值也就是对应多项式的 $n$ 个根。&lt;/p&gt;
&lt;p&gt;一些数值库，比如numpy，就是通过对角化友矩阵来求多项式的根的。
（那高次方程的根可以有解析表达式了？？不&amp;hellip;并没有，矩阵对角化的 QR 算法要无穷次迭代&amp;hellip;）&lt;/p&gt;
&lt;h2 id=&#34;哪里会出现友矩阵&#34;&gt;哪里会出现友矩阵？
&lt;/h2&gt;&lt;p&gt;在知乎上看到循环基中可以出现，在 Jinyu Li 的博客上看到多项式求余也可以导出友矩阵。两者类似，因为循环基和求余都涉及到把 $x^n$ 变成 $x^0,x^1,x^2,\cdots,x^{n-1}$ 。这里搬运一下后者。&lt;/p&gt;
&lt;p&gt;对于任意的多项式 $F(x)$，令多项式求余 $F(x) \mod P(x)=R(x)$ 。&lt;/p&gt;
&lt;p&gt;现在考虑一个新的多项式 $x F(x)$ ，同样关于 $P(x)$ 求余，记 $xF(x)\mod P(x)=S(x)$ 。由于 $R(x)$ 和 $S(x)$ 的次数均不超过 $n−1$ 次，用两个$n$ 维向量 $r,s\in R_n$ 分别表示 $x^0,x^1,x^2,\cdots , x^{n-1}$ 的系数。&lt;/p&gt;
&lt;p&gt;考察 $R(x)$ 和 $S(x)$ 的系数向量之间的关系，将 $r\mapsto s$ 的映射记为 $M$。如果 $r=(\alpha,0,0\cdots,0)$，那么 $s=(0,\alpha,0,0,\cdots,0)$，如果 $r=(0,\alpha,0,0\cdots,0)$，那么 $s=(0,0,\alpha,0,0,\cdots,0)$&amp;hellip;&lt;/p&gt;
&lt;p&gt;如果 $r=(0,0,\cdots,0,\alpha)$ ， 那么 $xR(x)$ 便为 $xR(x) = \alpha x^n = \alpha P(x)-\alpha c_0 - \alpha c_1 x - \cdots - \alpha c_{n-1} x^{n-1}$，所以此时 $s=(-\alpha c_0, -\alpha c_1, \cdots, -\alpha c_{n-1})$。&lt;/p&gt;
&lt;p&gt;容易看出上述这些 $r$ 的线性组合会带来对应 $s$ 的线性组合（因为求余的性质），所以 $M$ 是一个线性映射，它的矩阵表示就是上面定义的 $A$，$s=A r$。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Central Limit Theorem From RG</title>
        <link>http://localhost:1313/slices/central-limit-theorem-from-rg/</link>
        <pubDate>Sat, 17 May 2025 18:55:44 +0800</pubDate>
        
        <guid>http://localhost:1313/slices/central-limit-theorem-from-rg/</guid>
        <description>&lt;p&gt;想起之前在知乎上看到《Phase Transition and Renormalization Group》书中有一个从重整化的角度得到中心极限定理的推导，感觉很有意思，记录一下。&lt;/p&gt;
&lt;p&gt;假定有 $N=2^M$个独立同分布的随机变量 ${x_i}={x^{(0)}_i}$，概率密度函数记为 $f(x)=f^{(0)}(x)$。&lt;/p&gt;
&lt;p&gt;定义一次粗粒化过程为&lt;/p&gt;
$$x^{(T)}_i=\frac{x^{(T-1)}_{2i-1}+x^{(T-1)}_{2i}}{2^\nu}$$&lt;p&gt;它由最初的变量写出来就是&lt;/p&gt;
$$x^{(T)}_i=\frac{x^{(T-1)}_{2i-1}+x^{(T-1)}_{2i}}{2^\nu}=\frac{x^{(T-2)}_{4i-3}+x^{(T-2)}_{4i-2}+x^{(T-2)}_{4i-1}+x^{(T-2)}_{4i}}{2^{2\nu}}=\cdots=\frac{\sum_{j=2^T i - 2^T+1}^{2^T i} x^{(0)}_j}{2^{T\nu}}$$&lt;p&gt;$M$次粗粒化之后我们只剩下一个变量&lt;/p&gt;
$$x^{(M)}=x^{(M)}_1=\frac{\sum_{j=1}^N x^{(0)}_j}{N^\nu}$$&lt;p&gt;现在考虑粗粒化过程造成的分布的变换。记$x^{(T)}_i$的累计分布函数为$F^{(T)}(x)$，它等于&lt;/p&gt;
$$
\begin{aligned}
F^{(T)}(x)&amp;=\int \theta\left(x-\frac{y+z}{2^{\nu}}\right)f^{(T-1)}(y)f^{(T-1)}(z)dydz \\
&amp;=\int \theta\left(2^\nu x-y-z\right)f^{(T-1)}(y)f^{(T-1)}(z)dydz
\end{aligned}
$$&lt;p&gt;对它求导就得到概率密度函数$f^{(T)}(x)$&lt;/p&gt;
$$
\begin{aligned}
f^{(T)}(x)&amp;=2^\nu\int\delta(2^\nu x-y-z)f^{(T-1)}(y)f^{(T-1)}(z)dydz \\
&amp;=2^\nu \int f^{(T-1)}(2^\nu x-z)f^{(T-1)}(z)dz
\end{aligned}
$$&lt;p&gt;这是一个卷积。作傅里叶变换 $f^{(T)}(k)=\int f^{(T)}(x)e^{-ikx}dx,f^{(T)}(x)=\frac{1}{2\pi}\int f^{(T)}(k)e^{ikx}dk$，可以得到&lt;/p&gt;
$$
\begin{aligned}
f^{(T)}(k)&amp;=\int f^{(T)}(x)e^{-ikx}dx \\
&amp;=2^\nu \int f^{(T-1)}(2^\nu x-z)e^{-ik x}f^{(T-1)}(z)dxdz \\
&amp;= \int f^{(T-1)}(2^\nu x-z)e^{-ik(2^\nu x-z)/2^\nu}f^{(T-1)}(z)e^{-ikz/2^\nu} 2^\nu dxdz \\
&amp;= \left(f^{(T-1)}(k/2^\nu)\right)^2
\end{aligned}
$$&lt;p&gt;取对数 $w^{(T)}(k)=\ln f^{(T)}(k)$，所以 $w^{(T)}(k)=2w^{(T-1)}(k/2^\nu)$。&lt;/p&gt;
&lt;p&gt;作累积量展开
$w^{(T)}(k)=\sum_{n=1}^{\infty}\frac{(-i)^n}{n!}\kappa ^{(T)}_n k^n$ （$\kappa _0^{(T)}$等于零因为$f^{(T)}(k=0)=1$），$\kappa_1^{(T)}$是$f^{(T)}(x)$的均值，$\kappa_2^{(T)}$是$f^{(T)}(x)$的方差。容易看出各阶累积量的变换规则为&lt;/p&gt;
$$
\kappa_n^{(T)}=2^{1-n\nu}\kappa_n^{(T-1)}
$$&lt;p&gt;对于 $\nu=1/2$的情况，$\kappa_{n&amp;gt;2}^{(T)}$在变换中渐渐趋于零，$\kappa_{2}^{(T)}$保持不变，$\kappa_1^{(T)}$渐渐发散。对于扣除掉均值的随机变量${x^{(0)}_i-\braket{f(x)}}$，经过$M\to\infty$次变换后，一阶累积量始终等于零，高阶累积量趋于零，所以只剩下二阶累积量&lt;/p&gt;
$$
w_{shifted}^{(M\to\infty)}(k)=-\frac{\text{Var}f}{2}k^2, \quad f_{shifted}^{(M\to\infty)}(k)=e^{-\frac{\text{Var}f}{2}k^2}
$$&lt;p&gt;逆傅里叶变换就得到&lt;/p&gt;
$$
f_{shifted}^{(M\to\infty)}(x)=\frac{1}{\sqrt{2\pi \text{Var}f}}e^{-\frac{x^2}{2\text{Var}f}}\Rightarrow f^{(M\to\infty)}(x)=\frac{1}{\sqrt{2\pi \text{Var}f}}e^{-\frac{(x-\braket{f})^2}{2\text{Var}f}}
$$&lt;p&gt;注意到 $\nu=1/2$时，我们最终得到的随机变量也就是&lt;/p&gt;
$$
x^{(M\to\infty)}=\lim_{N\to\infty}\frac{\sum_{j=1}^N x_j^{(0)}}{\sqrt{N}}
$$&lt;p&gt;所以这其实就是中心极限定理。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>N Solitons Construction of KdV eq</title>
        <link>http://localhost:1313/slices/n-solitons-construction-of-kdv-eq/</link>
        <pubDate>Sat, 05 Apr 2025 17:40:49 +0800</pubDate>
        
        <guid>http://localhost:1313/slices/n-solitons-construction-of-kdv-eq/</guid>
        <description>&lt;p&gt;最近看了一点李翊神的《孤子与可积系统》，发现用达布变换构造的KdV方程的N孤子解形式很规则，感觉很新奇。但书中没有给出证明，这里试着自己推一遍。&lt;/p&gt;
&lt;h2 id=&#34;前置信息&#34;&gt;前置信息
&lt;/h2&gt;&lt;p&gt;假定$\phi$满足谱方程$L\phi=\lambda \phi$，同时又满足$\phi_t=A\phi$，可以导出$L,A$满足拉克斯方程$L_t =[A,L]$。&lt;/p&gt;
&lt;p&gt;若选取$L$为薛定谔算子$L=\partial_{xx}+u(x,t)$，$A$为反对称算子$A=-4\left(\partial_{xxx}+\frac{3}{4}u\partial_x+\partial_x \frac{3}{4}u\cdot\right)$，代入拉克斯方程可以得到$u$满足KdV方程&lt;/p&gt;
$$
u_t + u_{xxx} + 6 u u_x = 0
$$&lt;p&gt;$L\phi=\lambda\phi$对$x$求导后，代入$\phi_t=A\phi$中消去$\phi_{xxx}$项，得到$\phi$满足的另一个方程&lt;/p&gt;
$$
\phi_t = u_x\phi - (4\lambda+2u)\phi_x
$$&lt;p&gt;这个推导可以逆过来，从$\phi$满足$L\phi=\lambda\phi$和$\phi_t = u_x\phi - (4\lambda+2u)\phi_x$可以得出$\phi_t=A\phi$，从而导出$u$满足KdV方程。&lt;/p&gt;
&lt;h2 id=&#34;达布定理&#34;&gt;达布定理
&lt;/h2&gt;&lt;p&gt;假定${\phi,u}$是满足如下方程的一组解&lt;/p&gt;
$$
\begin{cases}
\phi_{xx}+u\phi=\lambda \phi \\
\phi_t = u_x\phi - (4\lambda+2u)\phi_x \\
\Rightarrow (u_t + u_{xxx} + 6 u u_x = 0)
\end{cases}
$$&lt;p&gt;${f,u}$是谱参数不同的另一组解&lt;/p&gt;
$$
\begin{cases}
f_{xx}+uf=\lambda_1 f \\
f_t = u_x f - (4\lambda_1+2u)f_x \\
\Rightarrow (u_t + u_{xxx} + 6 u u_x = 0)
\end{cases}
$$&lt;p&gt;作达布变换&lt;/p&gt;
$$
\begin{cases}
\bar{\phi} = \phi_x - \frac{f_x}{f}\phi \\
\bar{u} = u + 2[\ln f]_{xx}
\end{cases}
$$&lt;p&gt;可以证明${\bar{\phi},\bar{u}}$也满足谱参数为$\lambda$的方程&lt;/p&gt;
$$
\begin{cases}
\bar{\phi}_{xx}+\bar{u}\bar{\phi}=\lambda \bar{\phi} \\
\bar{\phi}_t = \bar{u}_x\bar{\phi} - (4\lambda+2\bar{u})\bar{\phi}_x \\
\Rightarrow (\bar{u}_t + \bar{u}_{xxx} + 6 \bar{u} \bar{u}_x = 0)
\end{cases}
$$&lt;p&gt;于是通过这种方式就实现了从KdV方程的一个解$u$出发构造另一个解$\bar{u}$。&lt;/p&gt;
&lt;h2 id=&#34;双孤子解&#34;&gt;双孤子解
&lt;/h2&gt;&lt;p&gt;选取初始种子$u[0]=0$，对应的解$\phi[0]=f(\lambda)$。记$f(\lambda_1)$为$u=0$时另一个谱参数$\lambda_1$下的解，那么由达布变换&lt;/p&gt;
$$
\begin{cases}
\phi[1]= f_x(\lambda) - \frac{f_x(\lambda_1)}{f(\lambda_1)}f(\lambda) = \frac{f_x(\lambda)f(\lambda_1)-f(\lambda)f_x(\lambda_1)}{f(\lambda_1)} \\
u[1]= 2[\ln f(\lambda_1)]_{xx}
\end{cases}
$$&lt;p&gt;${\phi[1],u[1]}$满足&lt;/p&gt;
$$
\begin{cases}
\phi[1]_{xx}+u[1]\phi[1]=\lambda \phi[1] \\
\phi[1]_t = u[1]_x\phi[1] - (4\lambda+2u[1])\phi[1]_x \\
\Rightarrow (u[1]_t + u[1]_{xxx} + 6 u[1] u[1]_x = 0)
\end{cases}
$$&lt;p&gt;由于$u[1]$和$\lambda$没有关系，容易看出可以存在$f[1]$满足&lt;/p&gt;
$$
\begin{cases}
f[1]_{xx}+u[1]f[1]=\lambda_2 f[1] \\
f[1]_t = u[1]_x f[1] - (4\lambda_2+2u[1])f[1]_x \\
\Rightarrow (u[1]_t + u[1]_{xxx} + 6 u[1] u[1]_x = 0)
\end{cases}
$$$$
f[1]= \frac{f_x(\lambda_2)f(\lambda_1)-f(\lambda_2)f_x(\lambda_1)}{f(\lambda_1)} 
$$&lt;p&gt;其中$f(\lambda_2)$是$u=0$时谱参数为$\lambda_2$时的解。于是我们可以利用$\phi[1],u[1],f[1]$继续做达布变换得到双孤子解&lt;/p&gt;
$$
\begin{cases}
\phi[2]= \phi_x[1] - \frac{f_x[1]}{f[1]}\phi[1]=
\frac{
\left|
\begin{array}{ccc}
f(\lambda_1) &amp;f_x(\lambda_1) &amp;f_{xx}(\lambda_1) \\
f(\lambda_2) &amp;f_x(\lambda_2) &amp;f_{xx}(\lambda_2) \\
f(\lambda) &amp;f_x(\lambda) &amp;f_{xx}(\lambda)
\end{array}\right|
}
{\left|
\begin{array}{cc}
f(\lambda_1) &amp;f_x(\lambda_1) \\
f(\lambda_2) &amp;f_x(\lambda_2)
\end{array}\right|}=\frac{w[f(\lambda_1),f(\lambda_2),f(\lambda)]}{w[f(\lambda_1),f(\lambda_2)]}
\\
u[2]= u[1] + 2[\ln f[1]]_{xx} = 2\left[\ln \left|
\begin{array}{cc}
f(\lambda_1) &amp; f_x(\lambda_1) \\
f(\lambda_2) &amp; f_x(\lambda_2)
\end{array}\right|\right]_{xx}=2[\ln w[f(\lambda_1),f(\lambda_2)]]_{xx}
\end{cases}
$$&lt;p&gt;其中$w[\cdots]$是朗斯基行列式。&lt;/p&gt;
&lt;h2 id=&#34;n孤子解&#34;&gt;N孤子解
&lt;/h2&gt;&lt;p&gt;从上面的结果可以猜测$n$孤子解的形式&lt;/p&gt;
$$
\begin{cases}
\phi[n] = \frac{w[f(\lambda_1),\cdots,f(\lambda_n), f(\lambda)]}{w[f(\lambda_1),\cdots,f(\lambda_n)]} \\
u[n] = 2[\ln w[f(\lambda_1),\cdots,f(\lambda_n)]]_{xx}
\end{cases}
$$&lt;p&gt;下面将通过归纳法证明这个式子，不过在此之前先推导一些朗斯基行列式相关的公式。&lt;/p&gt;
&lt;h2 id=&#34;朗斯基行列式求导&#34;&gt;朗斯基行列式求导
&lt;/h2&gt;$$
w[f(\lambda_1),\cdots,f(\lambda_n)]=\left|
\begin{array}{c}
f(\lambda_1) &amp;\cdots &amp;f^{(n-1)}(\lambda_1) &amp;f^{(n)}(\lambda_1) \\
f(\lambda_2) &amp;\cdots &amp;f^{(n-1)}(\lambda_2) &amp;f^{(n)}(\lambda_2) \\
\vdots &amp;\vdots &amp;\vdots &amp;\vdots \\
f(\lambda_n) &amp;\cdots &amp;f^{(n-1)}(\lambda_n) &amp;f^{(n)}(\lambda_n)
\end{array}
\right|
$$&lt;p&gt;将朗斯基行列式展开为$n!$项，对每一个乘积项应用莱布尼兹法则，再按照求导作用到的位置将所得到的$n\times n!$项分类，恢复成$n$个行列式，可以发现其中有$n-1$个行列式均为零（因为有相同的列），所以朗斯基行列式求导等于&lt;/p&gt;
$$
w_x[f(\lambda_1),\cdots,f(\lambda_n)]=\left|
\begin{array}{c}
f(\lambda_1) &amp;\cdots &amp;f^{(n-1)}(\lambda_1) &amp;f^{(n+1)}(\lambda_1) \\
f(\lambda_2) &amp;\cdots &amp;f^{(n-1)}(\lambda_2) &amp;f^{(n+1)}(\lambda_2) \\
\vdots &amp;\vdots &amp;\vdots &amp;\vdots \\
f(\lambda_n) &amp;\cdots &amp;f^{(n-1)}(\lambda_n) &amp;f^{(n+1)}(\lambda_n)
\end{array}
\right|
$$&lt;h2 id=&#34;分块矩阵行列式&#34;&gt;分块矩阵行列式
&lt;/h2&gt;&lt;p&gt;分块矩阵求行列式有如下公式&lt;/p&gt;
$$
\left|
\begin{array}{c}
 A  &amp; B \\
 C  &amp; D
\end{array}
\right| = |A| |D - C A^{-1} B|
$$&lt;p&gt;应用到朗斯基行列式中有&lt;/p&gt;
$$
\begin{aligned}
w[f(\lambda_1),\cdots,f(\lambda_n), f(\lambda_{n+1})]&amp;=\left|
\begin{array}{c}
f(\lambda_1) &amp;\cdots  &amp;f^{(n)}(\lambda_1) &amp;f^{(n+1)}(\lambda_1) \\
f(\lambda_2) &amp;\cdots  &amp;f^{(n)}(\lambda_2)  &amp;f^{(n+1)}(\lambda_2)\\
\vdots &amp;\vdots &amp;\vdots &amp;\vdots  \\
f(\lambda_n) &amp;\cdots &amp;f^{(n)}(\lambda_n) &amp;f^{(n+1)}(\lambda_n)\\
f(\lambda_{n+1}) &amp;\cdots &amp;f^{(n)}(\lambda_{n+1})  &amp;f^{(n+1)}(\lambda_{n+1})
\end{array} 
\right|\\
&amp;=w[f(\lambda_1),\cdots,f(\lambda_n)] ( f^{(n+1)}(\lambda_{n+1}) - C(\lambda_{n+1},n) W^{-1}(f(\lambda_1),\cdots,f(\lambda_n)) B(n+1,\lambda_{n}) )
\end{aligned}
$$$$
\begin{aligned}
w_x[f(\lambda_1),\cdots,f(\lambda_n), f(\lambda_{n+1})]&amp;=\left|
\begin{array}{c}
f(\lambda_1) &amp;\cdots  &amp;f^{(n)}(\lambda_1) &amp;f^{(n+2)}(\lambda_1) \\
f(\lambda_2) &amp;\cdots  &amp;f^{(n)}(\lambda_2)  &amp;f^{(n+2)}(\lambda_2)\\
\vdots &amp;\vdots &amp;\vdots &amp;\vdots  \\
f(\lambda_n) &amp;\cdots &amp;f^{(n)}(\lambda_n) &amp;f^{(n+2)}(\lambda_n)\\
f(\lambda_{n+1}) &amp;\cdots &amp;f^{(n)}(\lambda_{n+1})  &amp;f^{(n+2)}(\lambda_{n+1})
\end{array} 
\right|\\
&amp;=w[f(\lambda_1),\cdots,f(\lambda_n)] ( f^{(n+2)}(\lambda_{n+1}) - C(\lambda_{n+1},n) W^{-1}(f(\lambda_1),\cdots,f(\lambda_n)) B(n+2,\lambda_{n}) )
\end{aligned}
$$$$
\begin{aligned}
w[f(\lambda_1),\cdots,f(\lambda_n), f(\lambda)]&amp;=\left|
\begin{array}{c}
f(\lambda_1) &amp;\cdots  &amp;f^{(n)}(\lambda_1) &amp;f^{(n+1)}(\lambda_1) \\
f(\lambda_2) &amp;\cdots  &amp;f^{(n)}(\lambda_2)  &amp;f^{(n+1)}(\lambda_2)\\
\vdots &amp;\vdots &amp;\vdots &amp;\vdots  \\
f(\lambda_n) &amp;\cdots &amp;f^{(n)}(\lambda_n) &amp;f^{(n+1)}(\lambda_n)\\
f(\lambda) &amp;\cdots &amp;f^{(n)}(\lambda)  &amp;f^{(n+1)}(\lambda)
\end{array} 
\right|\\
&amp;=w[f(\lambda_1),\cdots,f(\lambda_n)] ( f^{(n+1)}(\lambda) - C(\lambda,n) W^{-1}(f(\lambda_1),\cdots,f(\lambda_n)) B(n+1,\lambda_{n}) )
\end{aligned}
$$$$
\begin{aligned}
w_x[f(\lambda_1),\cdots,f(\lambda_n), f(\lambda)]&amp;=\left|
\begin{array}{c}
f(\lambda_1) &amp;\cdots  &amp;f^{(n)}(\lambda_1) &amp;f^{(n+2)}(\lambda_1) \\
f(\lambda_2) &amp;\cdots  &amp;f^{(n)}(\lambda_2)  &amp;f^{(n+2)}(\lambda_2)\\
\vdots &amp;\vdots &amp;\vdots &amp;\vdots  \\
f(\lambda_n) &amp;\cdots &amp;f^{(n)}(\lambda_n) &amp;f^{(n+2)}(\lambda_n)\\
f(\lambda) &amp;\cdots &amp;f^{(n)}(\lambda)  &amp;f^{(n+2)}(\lambda)
\end{array} 
\right|\\
&amp;=w[f(\lambda_1),\cdots,f(\lambda_n)] ( f^{(n+2)}(\lambda) - C(\lambda,n) W^{-1}(f(\lambda_1),\cdots,f(\lambda_n)) B(n+2,\lambda_{n}) )
\end{aligned}
$$$$
\begin{aligned}
w[f(\lambda_1),\cdots,f(\lambda_n), f(\lambda_{n+1}), f(\lambda)]&amp;=\left|
\begin{array}{c}
f(\lambda_1) &amp;\cdots  &amp;f^{(n)}(\lambda_1) &amp;f^{(n+1)}(\lambda_1) &amp;f^{(n+2)}(\lambda_1) \\
f(\lambda_2) &amp;\cdots  &amp;f^{(n)}(\lambda_2)  &amp;f^{(n+1)}(\lambda_2) &amp;f^{(n+2)}(\lambda_2) \\
\vdots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\vdots \\
f(\lambda_n) &amp;\cdots &amp;f^{(n)}(\lambda_n) &amp;f^{(n+1)}(\lambda_n)  &amp;f^{(n+2)}(\lambda_n) \\
f(\lambda_{n+1}) &amp;\cdots &amp;f^{(n)}(\lambda_{n+1})  &amp;f^{(n+1)}(\lambda_{n+1})  &amp;f^{(n+2)}(\lambda_{n+1}) \\
f(\lambda) &amp;\cdots &amp;f^{(n)}(\lambda)  &amp;f^{(n+1)}(\lambda)  &amp;f^{(n+2)}(\lambda)
\end{array} 
\right|\\
&amp;=w[f(\lambda_1),\cdots,f(\lambda_n)]\left|
\left(
\begin{matrix}
f^{(n+1)}(\lambda_{n+1}) &amp; f^{(n+2)}(\lambda_{n+1}) \\
f^{(n+1)}(\lambda) &amp; f^{(n+2)}(\lambda)
\end{matrix}
\right)- 
\left(
\begin{matrix}
C(\lambda_{n+1},n) \\
C(\lambda,n)
\end{matrix}
\right)
W^{-1}(f(\lambda_1),\cdots,f(\lambda_n)) 
\left(
\begin{matrix}
B(n+1,\lambda_{n}) &amp; B(n+2,\lambda_{n})
\end{matrix}
\right)
\right| \\
&amp;=w[f(\lambda_1),\cdots,f(\lambda_n)]
\left|
\begin{array}{c}
f^{(n+1)}(\lambda_{n+1}) - C(\lambda_{n+1},n) W^{-1}(f(\lambda_1),\cdots,f(\lambda_n)) B(n+1,\lambda_{n}) &amp; f^{(n+2)}(\lambda_{n+1}) - C(\lambda_{n+1},n) W^{-1}(f(\lambda_1),\cdots,f(\lambda_n)) B(n+2,\lambda_{n}) \\
f^{(n+1)}(\lambda) - C(\lambda,n) W^{-1}(f(\lambda_1),\cdots,f(\lambda_n)) B(n+1,\lambda_{n}) &amp; f^{(n+2)}(\lambda) - C(\lambda,n) W^{-1}(f(\lambda_1),\cdots,f(\lambda_n)) B(n+2,\lambda_{n}) 
\end{array}    
\right| \\
&amp;= \frac{w_x[f(\lambda_1),\cdots,f(\lambda_n), f(\lambda)]w[f(\lambda_1),\cdots,f(\lambda_n), f(\lambda_{n+1})] - w[f(\lambda_1),\cdots,f(\lambda_n), f(\lambda)] w_x[f(\lambda_1),\cdots,f(\lambda_n), f(\lambda_{n+1})]}{w[f(\lambda_1),\cdots,f(\lambda_n)]}
\end{aligned}
$$&lt;p&gt;其中&lt;/p&gt;
$$
\begin{aligned}
W(f(\lambda_1),\cdots,f(\lambda_n)) &amp; =\left(
\begin{array}{c}
f(\lambda_1) &amp;\cdots &amp;f^{(n-1)}(\lambda_1) &amp;f^{(n)}(\lambda_1) \\
f(\lambda_2) &amp;\cdots &amp;f^{(n-1)}(\lambda_2) &amp;f^{(n)}(\lambda_2) \\
\vdots &amp;\vdots &amp;\vdots &amp;\vdots \\
f(\lambda_n) &amp;\cdots &amp;f^{(n-1)}(\lambda_n) &amp;f^{(n)}(\lambda_n)
\end{array}
\right) \\
C(\lambda_{n+1},n) &amp;= \left( 
\begin{matrix}
f(\lambda_{n+1}) &amp;\cdots &amp;f^{(n-1)}(\lambda_{n+1}) &amp;f^{(n)}(\lambda_{n+1})    
\end{matrix}
\right) \\
C(\lambda,n) &amp;= \left( 
\begin{matrix}
f(\lambda) &amp;\cdots &amp;f^{(n-1)}(\lambda) &amp;f^{(n)}(\lambda)    
\end{matrix}
\right) \\
B(n+1,\lambda_{n}) &amp;= \left(
\begin{matrix}
f^{(n+1)}(\lambda_1) \\
\vdots \\
f^{(n+1)}(\lambda_{n-1}) \\
f^{(n+1)}(\lambda_{n})
\end{matrix}
\right) \\
B(n+2,\lambda_{n}) &amp;= \left(
\begin{matrix}
f^{(n+2)}(\lambda_1) \\
\vdots \\
f^{(n+2)}(\lambda_{n-1}) \\
f^{(n+2)}(\lambda_{n})
\end{matrix}
\right)
\end{aligned}
$$&lt;h2 id=&#34;归纳证明&#34;&gt;归纳证明
&lt;/h2&gt;&lt;p&gt;假定$n$孤子解有如下形式&lt;/p&gt;
$$
\begin{cases}
\phi[n] = \frac{w[f(\lambda_1),\cdots,f(\lambda_n), f(\lambda)]}{w[f(\lambda_1),\cdots,f(\lambda_n)]} \\
u[n] = 2[\ln w[f(\lambda_1),\cdots,f(\lambda_n)]]_{xx}
\end{cases}
$$&lt;p&gt;现在证明利用$f[n] = \frac{w[f(\lambda_1),\cdots,f(\lambda_{n}), f(\lambda_{n+1})]}{w[f(\lambda_1),\cdots,f(\lambda_{n})]}$进行达布变换后的$n+1$孤子解为&lt;/p&gt;
$$
\begin{cases}
\phi[n+1] = \frac{w[f(\lambda_1),\cdots,f(\lambda_{n+1}), f(\lambda)]}{w[f(\lambda_1),\cdots,f(\lambda_{n+1})]} \\
u[n+1] = 2[\ln w[f(\lambda_1),\cdots,f(\lambda_{n+1})]]_{xx}
\end{cases}
$$&lt;p&gt;$u[n+1]$的证明是显然的，所以下面主要关注$\phi[n+1]$&lt;/p&gt;
$$
\begin{aligned}
&amp; \phi[n+1] =\phi_x[n] - \frac{f_x[n]}{f[n]}\phi[n]  \\
&amp; = 
\frac{w_x[f(\lambda_1),\cdots,f(\lambda_n), f(\lambda)]w[f(\lambda_1),\cdots,f(\lambda_n)] - w[f(\lambda_1),\cdots,f(\lambda_n), f(\lambda)] w_x[f(\lambda_1),\cdots,f(\lambda_n)]}{w^2[f(\lambda_1),\cdots,f(\lambda_n)]} \\
&amp; \quad - \frac{w_x[f(\lambda_1),\cdots,f(\lambda_n), f(\lambda_{n+1})]w[f(\lambda_1),\cdots,f(\lambda_n)] - w[f(\lambda_1),\cdots,f(\lambda_n), f(\lambda_{n+1})] w_x[f(\lambda_1),\cdots,f(\lambda_n)]}{w^2[f(\lambda_1),\cdots,f(\lambda_n)]}
\frac{w[f(\lambda_1),\cdots,f(\lambda_{n}),f(\lambda)]}{w[f(\lambda_1),\cdots,f(\lambda_{n}),f(\lambda_{n+1})]} \\
&amp; = \frac{w_x[f(\lambda_1),\cdots,f(\lambda_n), f(\lambda)]w[f(\lambda_1),\cdots,f(\lambda_{n}),f(\lambda_{n+1})]-w_x[f(\lambda_1),\cdots,f(\lambda_n), f(\lambda_{n+1})]w[f(\lambda_1),\cdots,f(\lambda_{n}),f(\lambda)]}{w[f(\lambda_1),\cdots,f(\lambda_n)] w[f(\lambda_1),\cdots,f(\lambda_{n}),f(\lambda_{n+1})]} \\
\end{aligned}
$$&lt;p&gt;利用上一小节证明的式子可以得到&lt;/p&gt;
$$
\phi[n+1]= \frac{w[f(\lambda_1),\cdots,f(\lambda_{n+1}), f(\lambda)]}{w[f(\lambda_1),\cdots,f(\lambda_{n+1})]}
$$&lt;p&gt;
这正是我们想要的结论。&lt;/p&gt;
&lt;h2 id=&#34;题外话-贝克隆变换和非线性叠加&#34;&gt;题外话-贝克隆变换和非线性叠加
&lt;/h2&gt;&lt;p&gt;另一种形式的$n$孤子解构造可以通过贝克隆变换后的非线性叠加公式得到，非常有趣。&lt;/p&gt;
&lt;p&gt;定义$w$满足方程$w_t+3w_x^2+w_{xxx}=0$，对它求导可以得到$u=w_x$满足KdV方程。将上面的达布变换应用到$w$上&lt;/p&gt;
$$
\begin{cases}
\bar{u} = u + 2(\ln f)_{xx} \\
(\bar{w}=w + 2(\ln f)_x) \\
f_{xx} + uf = \lambda f
\end{cases}
\Rightarrow
\bar{w}_x-w_x=2\frac{f_{xx}f - f^2_x}{f^2}=2\lambda-2w_x-\frac{1}{2}(\bar{w}-w)^2
$$$$
\Rightarrow \bar{w}_x + w_x = 2\lambda - \frac{1}{2}(\bar{w}-w)^2
$$&lt;p&gt;达布变换后$\bar{w}$依然满足$\bar{w}_t+3\bar{w}&lt;em&gt;x^2+\bar{w}&lt;/em&gt;{xxx}=0$，和$w$满足的方程作差得到&lt;/p&gt;
$$
\bar{w}_t - w_t + 3\bar{w}^2_x - 3 w^2_x + \bar{w}_{xxx} - w_{xxx} = 0
$$&lt;p&gt;这两个方程允许我们从$w$得到$\bar{w}$。&lt;/p&gt;
&lt;p&gt;假定我们从种子$w_0$出发通过参数为$\lambda_1$（$\lambda_2$）的变换得到了解$w_1$（$w_2$），然后再利用$w_1$通过参数为$\lambda_2$（$\lambda_1$）的变换得到了解$w_{12}$（$w_{21}$），令这两个解相等，就可以得到非线性叠加公式（也即从$w_1,w_2$出发代数叠加得到$w_{12}$）&lt;/p&gt;
$$
w_{12} = w_0 + \frac{4(\lambda_2 - \lambda_1)}{w_2 - w_1}
$$&lt;p&gt;这种叠加可以一直进行下去构造多孤子解，如图所示
&lt;img src=&#34;http://localhost:1313/slices/n-solitons-construction-of-kdv-eq/pics/nonlinear_superposition.png&#34;
	width=&#34;1875&#34;
	height=&#34;1338&#34;
	srcset=&#34;http://localhost:1313/slices/n-solitons-construction-of-kdv-eq/pics/nonlinear_superposition_hu18441511561763319404.png 480w, http://localhost:1313/slices/n-solitons-construction-of-kdv-eq/pics/nonlinear_superposition_hu6500832748828998836.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;140&#34;
		data-flex-basis=&#34;336px&#34;
	
&gt;
可以看出，非线性叠加的参数对称化要求（$w_{21}=w_{12}$）对于这种持续的构造是必要的，因为需要不同的参数解作为种子。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Collections of Notes</title>
        <link>http://localhost:1313/slices/collections-of-notes/</link>
        <pubDate>Sat, 18 Jan 2025 15:13:00 +0800</pubDate>
        
        <guid>http://localhost:1313/slices/collections-of-notes/</guid>
        <description>&lt;img src="http://localhost:1313/slices/collections-of-notes/notes_post_pic.jpg" alt="Featured image of post Collections of Notes" /&gt;&lt;h2 id=&#34;basic&#34;&gt;basic
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/solid_summary.pdf&#34; &gt;固体物理条目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/electrodynamics.pdf&#34; &gt;电动力学条目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/qm_summary.pdf&#34; &gt;基础量子力学&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/pst_summary.pdf&#34; &gt;传播子与散射&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/thermo_dy.pdf&#34; &gt;热力学要点&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/linear_response.pdf&#34; &gt;线性响应关系整理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/differentialgeometry.pdf&#34; &gt;微分几何条目&lt;/a&gt;（最早的小结，不是后来的风格，一些东西也没推完，待重制&amp;hellip;）
（但怎么说呢，也许风格自由也是初心的体现吧？）&lt;/p&gt;
&lt;h2 id=&#34;topic&#34;&gt;topic
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/bloch_boltzmann.pdf&#34; &gt;布洛赫输运&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/qhe_summary.pdf&#34; &gt;量子霍尔效应初步&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/sunandpermutation.pdf&#34; &gt;满足置换对称性的多体哈密顿量的$\mathfrak{su}(n)$约化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/manybodypeierls.pdf&#34; &gt;无杂质Peierls相变温度的多体理论计算&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/FRGefimov.pdf&#34; &gt;FRG视角下的Efimov效应&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/heavypolarons.pdf&#34; &gt;平均场费米超流中的重杂质相互作用&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;just-for-fun&#34;&gt;just for fun
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/partition_fun_divergent.pdf&#34; &gt;由配分函数发散想到&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;short-notes&#34;&gt;short notes
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/spin_squeezing.pdf&#34; &gt;自旋压缩态相关背景&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;math-tips&#34;&gt;math tips
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/high_d_taylor.pdf&#34; &gt;高维泰勒展开&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/lagrange_mul.pdf&#34; &gt;拉格朗日乘子法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/legendre_trans.pdf&#34; &gt;勒让德变换&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/residue.pdf&#34; &gt;留数定理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/jacobi_det.pdf&#34; &gt;雅可比行列式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;notes_dir/plemelj.pdf&#34; &gt;普莱姆利公式&lt;/a&gt;（更多内容可以看 &lt;a class=&#34;link&#34; href=&#34;notes_dir/Plemelj_Howard_E_Haber.pdf&#34; &gt;Howard E. Haber 的note&lt;/a&gt;）&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Bankrupt Probability</title>
        <link>http://localhost:1313/slices/bankrupt-probability/</link>
        <pubDate>Sun, 05 Jan 2025 18:32:40 +0800</pubDate>
        
        <guid>http://localhost:1313/slices/bankrupt-probability/</guid>
        <description>&lt;p&gt;最近了解到交易中破产概率的计算，觉得很有意思，也比较简单，记录一下。&lt;/p&gt;
&lt;p&gt;假定一个交易者胜率为$p$，每次止盈止损额度均为$s$，总亏损上限为$Ns$，那么他在市场上的破产概率$P_{b,N}$为&lt;/p&gt;
$$
P_{b,N} = 
\begin{cases}
 &amp; \left(\frac{1-p}{p}\right)^N  &amp; p\geq 0.5  \\
 &amp; 1  &amp; p\leq 0.5
\end{cases}.
$$&lt;h2 id=&#34;推导&#34;&gt;推导
&lt;/h2&gt;&lt;p&gt;假定交易者A和B进行交易，每次止盈止损额度均为$s$，A、B的总亏损上限分别为$Ns,Ms$，A的胜率为$p$。计算足够次数交易后，A把钱全部输给B的概率$P_{b,N}^M$，然后令$M\to\infty$得到$P_b$。&lt;/p&gt;
&lt;p&gt;设A在拥有亏损额度$ns$时，破产概率为$P_{b,n}^M$。交易一次后，A有概率$p$拥有$(n+1)s$亏损额度，概率$(1-p)$拥有$(n-1)s$亏损额度，于是&lt;/p&gt;
$$
P_{b,n}^M = (1-p)P_{b,n-1}^M + pP_{b,n+1}^M \Rightarrow
(1-p)(P_{b,n}^M - P_{b,n-1}^M) = p (P_{b,n+1}^M - P_{b,n}^M),
$$$$
\Rightarrow P^M_{b,n+1} - P^M_{b,n} = C_0\left(\frac{1-p}{p}\right)^n,
$$&lt;p&gt;其中$C_0=P^M_{b,1}-P^M_{b,0}$为常数。求和可以得到&lt;/p&gt;
$$
P^M_{b,n}-P^M_{b,0}=
\begin{cases}
 &amp; C_0 \frac{1-(1/p-1)^n}{2-1/p},  &amp; p\neq 0.5 \\
 &amp; n C_0,   &amp; p=0.5
\end{cases}.
$$$$
C_0 = 
\begin{cases}
 &amp; -\frac{2-1/p}{1-(1/p-1)^{N+M}},  &amp; p\neq 0.5 \\
 &amp; -\frac{1}{N+M},   &amp; p=0.5
\end{cases}.
$$&lt;p&gt;于是&lt;/p&gt;
$$
P^M_{b,N} = 
\begin{cases}
 &amp; 1 - \frac{1-(1/p-1)^N}{1-(1/p-1)^{N+M}} = \frac{(1/p-1)^N-(1/p-1)^{N+M}}{1-(1/p-1)^{N+M}},  &amp; p\neq 0.5 \\
 &amp; 1 - \frac{N}{N+M} = \frac{M}{N+M},  &amp; p=0.5
\end{cases}.
$$&lt;p&gt;取$M\to\infty$，&lt;/p&gt;
$$
P_{b,N} = \lim_{M\to\infty} P^M_{b,N} = 
\begin{cases}
 &amp; \lim_{M\to\infty} \frac{(1/p-1)^N-(1/p-1)^{N+M}}{1-(1/p-1)^{N+M}}=
 \begin{cases}
  &amp; 1, &amp;p &lt; 0.5 \\
  &amp; \left(\frac{1-p}{p}\right)^N, &amp;p &gt; 0.5
 \end{cases},  &amp; p\neq 0.5\\
 &amp; \lim_{M\to\infty} \frac{M}{N+M}=1   &amp; p=0.5
\end{cases}
$$&lt;p&gt;这就证明了开头的结论。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
