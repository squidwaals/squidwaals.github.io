[{"content":"之前了解到和结式相关的一些内容，感觉挺神奇的，跟着ai快速学习了一下，也稍微翻了翻范德瓦尔登的代数学，记录一下。\nSylvester行列式 在代数学中，结式（Resultant） 是一个用于研究多项式方程组解的重要工具，主要用于判断两个多项式是否有公共根（或公共因子）。\n设两个一元多项式：\n$ f(x) = a_n x^n + a_{n-1} x^{n-1} + \\dots + a_0 \\quad (a_n \\neq 0) $\n$ g(x) = b_m x^m + b_{m-1} x^{m-1} + \\dots + b_0 \\quad (b_m \\neq 0) $\n它们的结式是一个由系数 $a_i, b_j$ 构成的行列式（Sylvester行列式），记为 $\\text{Res}(f, g)$。其构造规则为：\n行列式共有 $n + m$ 行，前 $m$ 行由 $f(x)$ 的系数（从 $a_n$ 到 $a_0$）重复排列，每行向右移一位（空位补0）； 后 $n$ 行由 $g(x)$ 的系数（从 $b_m$ 到 $b_0$）重复排列，同样每行向右移一位（空位补0）。 $$ \\text{Res}(f,g) = \\begin{vmatrix} a_n \u0026 a_{n-1} \u0026 \\cdots \u0026 a_0 \u0026 0 \u0026 \\cdots \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 a_n \u0026 a_{n-1} \u0026 \\cdots \u0026 a_0 \u0026 \\cdots \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 a_n \u0026 a_{n-1} \u0026 \\cdots \u0026 \\cdots \u0026 a_0 \\\\ b_m\u0026 b_{m-1} \u0026 \\cdots \u0026 b_1 \u0026 b_0 \u0026 \\cdots \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 b_m \u0026 b_{m-1} \u0026 \\cdots \u0026 b_1 \u0026 \\cdots \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 b_m \u0026 b_{m-1} \u0026 \\cdots \u0026 b_1 \u0026 b_0\\\\ \\end{vmatrix} $$多项式公共根 两个多项式 $f(x)$ 和 $g(x)$ 有公共根的充要条件是它们的结式为0，即 $\\text{Res}(f, g) = 0$。\n证明核心思路: 结式为零等价于“存在非零多项式 $u(x), v(x)$ 使得 $u(x)f(x) = v(x)g(x)$，且 $\\deg u \u0026lt; m，\\deg v \u0026lt; n$”，而这又等价于 $f$ 和 $g$ 有公共因子。\n步骤1：结式为零 ⇨ 存在非零多项式 $u, v$ 满足 $uf = vg$ 结式 $\\text{Res}(f, g)$ 是某线性方程组系数矩阵的行列式。具体来说，考虑以下方程：\n$$ u(x)f(x) = v(x)g(x), $$其中 $ u(x) = c_{m-1}x^{m-1} + \\dots + c_0，v(x) = -d_{n-1}x^{n-1} - \\dots - d_0 $。\n两边展开后，同次幂的系数必须相等。对于 $x^k (k = 0, 1, \\dots, n+m-1)$，系数等式构成一个线性方程组，\n$$ \\begin{cases} c_{m-1} a_n + d_{n-1} b_m \u0026= 0 \\\\ c_{m-1} a_{n-1} + c_{m-2} a_n + d_{n-2} b_{m-1} + d_{n-1} b_m \u0026= 0 \\\\ \\vdots \\\\ c_0 a_0 + d_0 b_0 \u0026=0 \\\\ \\end{cases} $$其系数矩阵正是结式的行列式对应矩阵的转置。\n若 $\\text{Res}(f, g) = 0$，则该线性方程组有非零解 $(c_{m-1}, \\dots, c_{0}, d_{n-1}, \\dots, d_{0})$，即存在非零多项式 $u, v$ 使得 $uf = vg$。\n步骤2：存在非零 $u, v$ 满足 $uf = vg$ ⇨ $f, g$ 有公共因子 假设 $uf = vg$，其中 $u \\neq 0，v \\neq 0$，且 $\\deg u \u0026lt; m，\\deg v \u0026lt; n$。\n由于 $f$ 和 $g$ 非零，可设它们的最大公因子为 $d(x)$，即 $f = d \\cdot f_1，g = d \\cdot g_1$，其中 $\\gcd(f_1, g_1) = 1$（互素）。\n代入等式得 $u d f_1 = v d g_1$，约去 $d$ 后有 $u f_1 = v g_1$。因 $f_1$ 与 $g_1$ 互素，故 $f_1$ 必整除 $v$，$g_1$ 必整除 $u$。\n若 $d(x)$ 为常数（即 $f, g$ 互素），则 $f_1 = f，g_1 = g$，此时 $f$ 整除 $v$，$g$ 整除 $u$。但 $\\deg v \u0026lt; n = \\deg f$，$\\deg u \u0026lt; m = \\deg g$，故 $v$ 只能是零多项式，与 $v \\neq 0$ 矛盾。\n因此，$d(x)$ 必为次数至少1的多项式，即 $f$ 和 $g$ 有非平凡公共因子。\n步骤3：$f, g$ 有公共因子 ⇨ 结式为零 若 $f$ 和 $g$ 有公共根 $\\alpha$（或公共因子 $h(x) = (x - \\alpha) \\dots$），则 $f(\\alpha) = 0$ 且 $g(\\alpha) = 0$。\n考虑向量 $\\boldsymbol{\\alpha} = (\\alpha^{n+m-1}, \\alpha^{n+m-2}, \\dots, \\alpha, 1)^T$，代入结式的行列式矩阵 $M$ 中，可验证 $M \\boldsymbol{\\alpha} = \\boldsymbol{0}$ ：\n前 m 行：$a_n \\alpha^{n+m-k} + a_{n-1} \\alpha^{n+m-k-1} + \\dots + a_0 \\alpha^{m-k} = \\alpha^{m-k} f(\\alpha) = 0$（k 为行索引）； 后 n 行：$b_m \\alpha^{2m+n-k} + b_m \\alpha^{2m+n-k-1} + \\dots + b_0 \\alpha^{m+n-k} = \\alpha^{m+n-k} g(\\alpha) = 0$（k 为行索引）。 因此，矩阵 $M$ 有非零解 $\\boldsymbol{\\alpha}$，行列式 $\\text{Res}(f, g) = 0$。\n结式的这种和多项式公共根有关的性质可以用到解多项式方程组中。 比如在解二元多项式方程组 $f(x, y) = 0$ 和 $g(x, y) = 0$ 时，可将 $f, g$ 视为关于 $x$ 的多项式（视 $y$ 为常数），其结式 $\\text{Res}_x(f, g)$ 是关于 $y$ 的多项式，该多项式的根即为方程组解中 $y$ 的可能值（消去了 $x$）。\n根表达式 有了多项式公共根的性质，可以证明结式有一个漂亮简洁的多项式根的表达式。\n设${\\alpha_i}$是$f(x)$的根，${\\beta_j}$是$g(x)$的根，$f(x)=a_n\\prod_{i=1}^n(x-\\alpha_i)$，$g(x)=b_m \\prod_{j=1}^m (x-\\beta_j)$，多项式系数${a_i},{b_i}$是根的多项式，从而结式是根的多项式函数。\n固定$f(x)$的 $n-1$ 个根不变，固定$g(x)$的 $m-1$ 个根不变，将剩下的 $\\alpha_i$，$\\beta_j$ 当作变量。由结式的公共根性质可知，当 $\\alpha_i=\\beta_j$ 的时候，$\\text{Res}(f,g)=0$。又由于结式是根的多项式函数，所以\n$$ \\text{Res}(f,g)\\propto (\\alpha_i-\\beta_j)^{p},p\\geq 1 . $$这种性质对任意一对${\\alpha_i,\\beta_j}$均成立，所以\n$$ \\text{Res}(f,g)\\propto \\prod_{i=1}^n\\prod_{j=1}^m (\\alpha_i-\\beta_j)^{p_{ij}},p_{ij}\\geq 1 . $$注意到，对于任何根$\\alpha_i,\\beta_j$，多项式系数${a_i},{b_i}$是根的一次函数，从Sylvester行列式的表达式可以看出 $\\text{Res}(f,g)$ 中 $\\alpha_i$ 的最高次数是 $m$ 次，$\\beta_j$ 的最高次数是 $n$ 次，所以 $p_{ij} = 1$。\n此外，由于 $a_n$ 是系数${a_i}$ 的公共因子，$b_m$ 是系数 ${b_j}$ 的公共因子，所以\n$$ \\text{Res}(f,g)\\propto a_n^m b_m^n \\prod_{i=1}^n\\prod_{j=1}^m (\\alpha_i-\\beta_j). $$现在确定比例系数。考虑到 $b_0=b_m \\prod_{j=1}^m (-\\beta_j)$，从而上式右侧 $b_0$ 最高次项的系数为 $a_n^m$。而从Sylvester行列式看，$b_0$ 次数最高的行列式展开项就是沿着主对角线的乘积项，它的系数也是$a_n^m$。\n所以比例系数就等于1，结式可以写成\n$$ \\text{Res}(f, g) = a_n^m b_m^n \\prod_{i=1}^n\\prod_{j=1}^m (\\alpha_i - \\beta_j)= a_n^m \\prod_{i=1}^n g(\\alpha_i) = (-1)^{mn} \\cdot b_m^n \\prod_{j=1}^m f(\\beta_j). $$乘法性质 从结式的根表达式可以直接看出结式的乘法性质。\n设三个一元多项式：\n$ f(x) = a_n x^n + a_{n-1} x^{n-1} + \\dots + a_0=a_n\\prod_{i=1}^n (x-\\alpha_i) \\quad (a_n \\neq 0)， $\n$ g(x) = b_m x^m + b_{m-1} x^{m-1} + \\dots + b_0=b_m\\prod_{j=1}^m (x-\\beta_j) \\quad (b_m \\neq 0)， $\n$ h(x) = c_l x^l + c_{l-1} x^{l-1} + \\dots + c_0=c_l\\prod_{k=1}^l(x-\\gamma_k) \\quad (c_l \\neq 0)， $\n容易看出\n$$ \\begin{aligned} \\text{Res}(fg,h)\u0026= (a_n b_m)^l c_l^{m+n} \\prod_{i=1}^{n}\\prod_{k=1}^l (\\alpha_i-\\gamma_k) \\prod_{j=1}^{m}\\prod_{k=1}^l (\\beta_j - \\gamma_k) \\\\ \u0026= \\left(a_n^l c_l^n \\prod_{i=1}^{n}\\prod_{k=1}^l (\\alpha_i-\\gamma_k)\\right) \\left( b_m^l c_l^m \\prod_{j=1}^{m}\\prod_{k=1}^l (\\beta_j - \\gamma_k) \\right) \\\\ \u0026= \\text{Res}(f,h) \\text{Res}(g,h) \\end{aligned}, $$$$ \\begin{aligned} \\text{Res}(f,gh)\u0026= a_n^{m+l} {(b_m c_l)}^{n} \\prod_{i=1}^{n}\\prod_{j=1}^m (\\alpha_i-\\beta_j) \\prod_{i=1}^{n}\\prod_{k=1}^l (\\alpha_i - \\gamma_k) \\\\ \u0026= \\left(a_n^m b_m^n \\prod_{i=1}^{n}\\prod_{j=1}^m (\\alpha_i-\\beta_j) \\right) \\left(a_n^l c_l^n \\prod_{i=1}^{n}\\prod_{k=1}^l (\\alpha_i - \\gamma_k) \\right)\\\\ \u0026= \\text{Res}(f,g) \\text{Res}(f,h) \\end{aligned}. $$","date":"2025-08-17T18:12:59+08:00","permalink":"http://localhost:1313/slices/resultants-basics/","title":"Resultants Basics"},{"content":"最近了解到多项式友矩阵的相关内容，好像挺基础的，但之前不知道，所以记录一下。\n友矩阵 友矩阵的定义是\n$$ A=\\left( \\begin{array}{c} 0 \u0026 0 \u0026\\cdots \u00260 \u00260 \u0026 -c_0 \\\\ 1 \u0026 0 \u0026\\cdots \u00260 \u00260 \u0026 -c_1 \\\\ 0 \u0026 1 \u0026\\cdots \u00260 \u00260 \u0026 -c_2 \\\\ \\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \\\\ 0 \u0026 0 \u0026\\cdots \u00261 \u00260 \u0026 -c_{n-2}\\\\ 0 \u0026 0 \u0026\\cdots \u00260 \u00261 \u0026 -c_{n-1} \\end{array} \\right) $$它的 $n$ 个特征值正好是多项式 $P(x)=x^n+c_{n-1}x^{n-1}+\\cdots+c_0$ 的$n$个根。\n证明 可以计算矩阵 $A$ 的特征多项式直接证明\n$$ \\begin{aligned} |\\lambda I - A| \u0026=\\left| \\begin{array}{c} \\lambda \u0026 0 \u0026\\cdots \u00260 \u00260 \u0026 c_0 \\\\ -1 \u0026 \\lambda \u0026\\cdots \u00260 \u00260 \u0026 c_1 \\\\ 0 \u0026 -1 \u0026\\cdots \u00260 \u00260 \u0026 c_2 \\\\ \\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \\\\ 0 \u0026 0 \u0026\\cdots \u0026-1 \u0026\\lambda \u0026 c_{n-2}\\\\ 0 \u0026 0 \u0026\\cdots \u00260 \u0026-1 \u0026 \\lambda+c_{n-1} \\end{array} \\right|_n \\\\ \u0026= \\lambda \\left| \\begin{array}{c} \\lambda \u0026 0 \u0026\\cdots \u00260 \u00260 \u0026 c_1 \\\\ -1 \u0026 \\lambda \u0026\\cdots \u00260 \u00260 \u0026 c_2 \\\\ 0 \u0026 -1 \u0026\\cdots \u00260 \u00260 \u0026 c_3 \\\\ \\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \\\\ 0 \u0026 0 \u0026\\cdots \u0026-1 \u0026\\lambda \u0026 c_{n-2}\\\\ 0 \u0026 0 \u0026\\cdots \u00260 \u0026-1 \u0026 \\lambda+c_{n-1} \\end{array} \\right|_{n-1}+(-1)^{n-1}c_0 \\left| \\begin{array}{c} -1 \u0026 \\lambda \u0026\\cdots \u00260 \u00260 \\\\ 0 \u0026 -1 \u0026\\cdots \u00260 \u00260 \\\\ \\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \\\\ 0 \u0026 0 \u0026\\cdots \u0026-1 \u0026\\lambda \\\\ 0 \u0026 0 \u0026\\cdots \u00260 \u0026-1 \\end{array} \\right|_{n-1} \\\\ \u0026= \\lambda \\left| \\begin{array}{c} \\lambda \u0026 0 \u0026\\cdots \u00260 \u00260 \u0026 c_1 \\\\ -1 \u0026 \\lambda \u0026\\cdots \u00260 \u00260 \u0026 c_2 \\\\ 0 \u0026 -1 \u0026\\cdots \u00260 \u00260 \u0026 c_3 \\\\ \\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \\\\ 0 \u0026 0 \u0026\\cdots \u0026-1 \u0026\\lambda \u0026 c_{n-2}\\\\ 0 \u0026 0 \u0026\\cdots \u00260 \u0026-1 \u0026 \\lambda+c_{n-1} \\end{array} \\right|_{n-1}+c_0 \\\\ \u0026= \\lambda^2 \\left| \\begin{array}{c} \\lambda \u0026 0 \u0026\\cdots \u00260 \u00260 \u0026 c_2 \\\\ -1 \u0026 \\lambda \u0026\\cdots \u00260 \u00260 \u0026 c_3 \\\\ 0 \u0026 -1 \u0026\\cdots \u00260 \u00260 \u0026 c_4 \\\\ \\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \\\\ 0 \u0026 0 \u0026\\cdots \u0026-1 \u0026\\lambda \u0026 c_{n-2}\\\\ 0 \u0026 0 \u0026\\cdots \u00260 \u0026-1 \u0026 \\lambda+c_{n-1} \\end{array} \\right|_{n-2}+\\lambda c_1+c_0 \\\\ \u0026=\\cdots \\\\ \u0026=\\lambda^{n-1} |\\lambda + c_{n-1}|_1 + \\lambda^{n-2}c_{n-2}+\\cdots+\\lambda c_1+c_0 \\\\ \u0026=\\lambda^n + \\lambda^{n-1}c_{n-1}+\\cdots+ \\lambda c_1 + c_0 \\end{aligned} $$可见矩阵 $A$ 的特征多项式正好就是 $P(x)=x^n+c_{n-1}x^{n-1}+\\cdots+c_0$，所以它的 $n$ 个特征值也就是对应多项式的 $n$ 个根。\n一些数值库，比如numpy，就是通过对角化友矩阵来求多项式的根的。 （那高次方程的根可以有解析表达式了？？不\u0026hellip;并没有，矩阵对角化的 QR 算法要无穷次迭代\u0026hellip;）\n哪里会出现友矩阵？ 在知乎上看到循环基中可以出现，在 Jinyu Li 的博客上看到多项式求余也可以导出友矩阵。两者类似，因为循环基和求余都涉及到把 $x^n$ 变成 $x^0,x^1,x^2,\\cdots,x^{n-1}$ 。这里搬运一下后者。\n对于任意的多项式 $F(x)$，令多项式求余 $F(x) \\mod P(x)=R(x)$ 。\n现在考虑一个新的多项式 $x F(x)$ ，同样关于 $P(x)$ 求余，记 $xF(x)\\mod P(x)=S(x)$ 。由于 $R(x)$ 和 $S(x)$ 的次数均不超过 $n−1$ 次，用两个$n$ 维向量 $r,s\\in R_n$ 分别表示 $x^0,x^1,x^2,\\cdots , x^{n-1}$ 的系数。\n考察 $R(x)$ 和 $S(x)$ 的系数向量之间的关系，将 $r\\mapsto s$ 的映射记为 $M$。如果 $r=(\\alpha,0,0\\cdots,0)$，那么 $s=(0,\\alpha,0,0,\\cdots,0)$，如果 $r=(0,\\alpha,0,0\\cdots,0)$，那么 $s=(0,0,\\alpha,0,0,\\cdots,0)$\u0026hellip;\n如果 $r=(0,0,\\cdots,0,\\alpha)$ ， 那么 $xR(x)$ 便为 $xR(x) = \\alpha x^n = \\alpha P(x)-\\alpha c_0 - \\alpha c_1 x - \\cdots - \\alpha c_{n-1} x^{n-1}$，所以此时 $s=(-\\alpha c_0, -\\alpha c_1, \\cdots, -\\alpha c_{n-1})$。\n容易看出上述这些 $r$ 的线性组合会带来对应 $s$ 的线性组合（因为求余的性质），所以 $M$ 是一个线性映射，它的矩阵表示就是上面定义的 $A$，$s=A r$。\n","date":"2025-07-05T13:14:24+08:00","permalink":"http://localhost:1313/slices/companion-matrix/","title":"Companion Matrix"},{"content":"想起之前在知乎上看到《Phase Transition and Renormalization Group》书中有一个从重整化的角度得到中心极限定理的推导，感觉很有意思，记录一下。\n假定有 $N=2^M$个独立同分布的随机变量 ${x_i}={x^{(0)}_i}$，概率密度函数记为 $f(x)=f^{(0)}(x)$。\n定义一次粗粒化过程为\n$$x^{(T)}_i=\\frac{x^{(T-1)}_{2i-1}+x^{(T-1)}_{2i}}{2^\\nu}$$它由最初的变量写出来就是\n$$x^{(T)}_i=\\frac{x^{(T-1)}_{2i-1}+x^{(T-1)}_{2i}}{2^\\nu}=\\frac{x^{(T-2)}_{4i-3}+x^{(T-2)}_{4i-2}+x^{(T-2)}_{4i-1}+x^{(T-2)}_{4i}}{2^{2\\nu}}=\\cdots=\\frac{\\sum_{j=2^T i - 2^T+1}^{2^T i} x^{(0)}_j}{2^{T\\nu}}$$$M$次粗粒化之后我们只剩下一个变量\n$$x^{(M)}=x^{(M)}_1=\\frac{\\sum_{j=1}^N x^{(0)}_j}{N^\\nu}$$现在考虑粗粒化过程造成的分布的变换。记$x^{(T)}_i$的累计分布函数为$F^{(T)}(x)$，它等于\n$$ \\begin{aligned} F^{(T)}(x)\u0026=\\int \\theta\\left(x-\\frac{y+z}{2^{\\nu}}\\right)f^{(T-1)}(y)f^{(T-1)}(z)dydz \\\\ \u0026=\\int \\theta\\left(2^\\nu x-y-z\\right)f^{(T-1)}(y)f^{(T-1)}(z)dydz \\end{aligned} $$对它求导就得到概率密度函数$f^{(T)}(x)$\n$$ \\begin{aligned} f^{(T)}(x)\u0026=2^\\nu\\int\\delta(2^\\nu x-y-z)f^{(T-1)}(y)f^{(T-1)}(z)dydz \\\\ \u0026=2^\\nu \\int f^{(T-1)}(2^\\nu x-z)f^{(T-1)}(z)dz \\end{aligned} $$这是一个卷积。作傅里叶变换 $f^{(T)}(k)=\\int f^{(T)}(x)e^{-ikx}dx,f^{(T)}(x)=\\frac{1}{2\\pi}\\int f^{(T)}(k)e^{ikx}dk$，可以得到\n$$ \\begin{aligned} f^{(T)}(k)\u0026=\\int f^{(T)}(x)e^{-ikx}dx \\\\ \u0026=2^\\nu \\int f^{(T-1)}(2^\\nu x-z)e^{-ik x}f^{(T-1)}(z)dxdz \\\\ \u0026= \\int f^{(T-1)}(2^\\nu x-z)e^{-ik(2^\\nu x-z)/2^\\nu}f^{(T-1)}(z)e^{-ikz/2^\\nu} 2^\\nu dxdz \\\\ \u0026= \\left(f^{(T-1)}(k/2^\\nu)\\right)^2 \\end{aligned} $$取对数 $w^{(T)}(k)=\\ln f^{(T)}(k)$，所以 $w^{(T)}(k)=2w^{(T-1)}(k/2^\\nu)$。\n作累积量展开 $w^{(T)}(k)=\\sum_{n=1}^{\\infty}\\frac{(-i)^n}{n!}\\kappa ^{(T)}_n k^n$ （$\\kappa _0^{(T)}$等于零因为$f^{(T)}(k=0)=1$），$\\kappa_1^{(T)}$是$f^{(T)}(x)$的均值，$\\kappa_2^{(T)}$是$f^{(T)}(x)$的方差。容易看出各阶累积量的变换规则为\n$$ \\kappa_n^{(T)}=2^{1-n\\nu}\\kappa_n^{(T-1)} $$对于 $\\nu=1/2$的情况，$\\kappa_{n\u0026gt;2}^{(T)}$在变换中渐渐趋于零，$\\kappa_{2}^{(T)}$保持不变，$\\kappa_1^{(T)}$渐渐发散。对于扣除掉均值的随机变量${x^{(0)}_i-\\braket{f(x)}}$，经过$M\\to\\infty$次变换后，一阶累积量始终等于零，高阶累积量趋于零，所以只剩下二阶累积量\n$$ w_{shifted}^{(M\\to\\infty)}(k)=-\\frac{\\text{Var}f}{2}k^2, \\quad f_{shifted}^{(M\\to\\infty)}(k)=e^{-\\frac{\\text{Var}f}{2}k^2} $$逆傅里叶变换就得到\n$$ f_{shifted}^{(M\\to\\infty)}(x)=\\frac{1}{\\sqrt{2\\pi \\text{Var}f}}e^{-\\frac{x^2}{2\\text{Var}f}}\\Rightarrow f^{(M\\to\\infty)}(x)=\\frac{1}{\\sqrt{2\\pi \\text{Var}f}}e^{-\\frac{(x-\\braket{f})^2}{2\\text{Var}f}} $$注意到 $\\nu=1/2$时，我们最终得到的随机变量也就是\n$$ x^{(M\\to\\infty)}=\\lim_{N\\to\\infty}\\frac{\\sum_{j=1}^N x_j^{(0)}}{\\sqrt{N}} $$所以这其实就是中心极限定理。\n","date":"2025-05-17T18:55:44+08:00","permalink":"http://localhost:1313/slices/central-limit-theorem-from-rg/","title":"Central Limit Theorem From RG"},{"content":"最近看了一点李翊神的《孤子与可积系统》，发现用达布变换构造的KdV方程的N孤子解形式很规则，感觉很新奇。但书中没有给出证明，这里试着自己推一遍。\n前置信息 假定$\\phi$满足谱方程$L\\phi=\\lambda \\phi$，同时又满足$\\phi_t=A\\phi$，可以导出$L,A$满足拉克斯方程$L_t =[A,L]$。\n若选取$L$为薛定谔算子$L=\\partial_{xx}+u(x,t)$，$A$为反对称算子$A=-4\\left(\\partial_{xxx}+\\frac{3}{4}u\\partial_x+\\partial_x \\frac{3}{4}u\\cdot\\right)$，代入拉克斯方程可以得到$u$满足KdV方程\n$$ u_t + u_{xxx} + 6 u u_x = 0 $$$L\\phi=\\lambda\\phi$对$x$求导后，代入$\\phi_t=A\\phi$中消去$\\phi_{xxx}$项，得到$\\phi$满足的另一个方程\n$$ \\phi_t = u_x\\phi - (4\\lambda+2u)\\phi_x $$这个推导可以逆过来，从$\\phi$满足$L\\phi=\\lambda\\phi$和$\\phi_t = u_x\\phi - (4\\lambda+2u)\\phi_x$可以得出$\\phi_t=A\\phi$，从而导出$u$满足KdV方程。\n达布定理 假定${\\phi,u}$是满足如下方程的一组解\n$$ \\begin{cases} \\phi_{xx}+u\\phi=\\lambda \\phi \\\\ \\phi_t = u_x\\phi - (4\\lambda+2u)\\phi_x \\\\ \\Rightarrow (u_t + u_{xxx} + 6 u u_x = 0) \\end{cases} $$${f,u}$是谱参数不同的另一组解\n$$ \\begin{cases} f_{xx}+uf=\\lambda_1 f \\\\ f_t = u_x f - (4\\lambda_1+2u)f_x \\\\ \\Rightarrow (u_t + u_{xxx} + 6 u u_x = 0) \\end{cases} $$作达布变换\n$$ \\begin{cases} \\bar{\\phi} = \\phi_x - \\frac{f_x}{f}\\phi \\\\ \\bar{u} = u + 2[\\ln f]_{xx} \\end{cases} $$可以证明${\\bar{\\phi},\\bar{u}}$也满足谱参数为$\\lambda$的方程\n$$ \\begin{cases} \\bar{\\phi}_{xx}+\\bar{u}\\bar{\\phi}=\\lambda \\bar{\\phi} \\\\ \\bar{\\phi}_t = \\bar{u}_x\\bar{\\phi} - (4\\lambda+2\\bar{u})\\bar{\\phi}_x \\\\ \\Rightarrow (\\bar{u}_t + \\bar{u}_{xxx} + 6 \\bar{u} \\bar{u}_x = 0) \\end{cases} $$于是通过这种方式就实现了从KdV方程的一个解$u$出发构造另一个解$\\bar{u}$。\n双孤子解 选取初始种子$u[0]=0$，对应的解$\\phi[0]=f(\\lambda)$。记$f(\\lambda_1)$为$u=0$时另一个谱参数$\\lambda_1$下的解，那么由达布变换\n$$ \\begin{cases} \\phi[1]= f_x(\\lambda) - \\frac{f_x(\\lambda_1)}{f(\\lambda_1)}f(\\lambda) = \\frac{f_x(\\lambda)f(\\lambda_1)-f(\\lambda)f_x(\\lambda_1)}{f(\\lambda_1)} \\\\ u[1]= 2[\\ln f(\\lambda_1)]_{xx} \\end{cases} $$${\\phi[1],u[1]}$满足\n$$ \\begin{cases} \\phi[1]_{xx}+u[1]\\phi[1]=\\lambda \\phi[1] \\\\ \\phi[1]_t = u[1]_x\\phi[1] - (4\\lambda+2u[1])\\phi[1]_x \\\\ \\Rightarrow (u[1]_t + u[1]_{xxx} + 6 u[1] u[1]_x = 0) \\end{cases} $$由于$u[1]$和$\\lambda$没有关系，容易看出可以存在$f[1]$满足\n$$ \\begin{cases} f[1]_{xx}+u[1]f[1]=\\lambda_2 f[1] \\\\ f[1]_t = u[1]_x f[1] - (4\\lambda_2+2u[1])f[1]_x \\\\ \\Rightarrow (u[1]_t + u[1]_{xxx} + 6 u[1] u[1]_x = 0) \\end{cases} $$$$ f[1]= \\frac{f_x(\\lambda_2)f(\\lambda_1)-f(\\lambda_2)f_x(\\lambda_1)}{f(\\lambda_1)} $$其中$f(\\lambda_2)$是$u=0$时谱参数为$\\lambda_2$时的解。于是我们可以利用$\\phi[1],u[1],f[1]$继续做达布变换得到双孤子解\n$$ \\begin{cases} \\phi[2]= \\phi_x[1] - \\frac{f_x[1]}{f[1]}\\phi[1]= \\frac{ \\left| \\begin{array}{ccc} f(\\lambda_1) \u0026f_x(\\lambda_1) \u0026f_{xx}(\\lambda_1) \\\\ f(\\lambda_2) \u0026f_x(\\lambda_2) \u0026f_{xx}(\\lambda_2) \\\\ f(\\lambda) \u0026f_x(\\lambda) \u0026f_{xx}(\\lambda) \\end{array}\\right| } {\\left| \\begin{array}{cc} f(\\lambda_1) \u0026f_x(\\lambda_1) \\\\ f(\\lambda_2) \u0026f_x(\\lambda_2) \\end{array}\\right|}=\\frac{w[f(\\lambda_1),f(\\lambda_2),f(\\lambda)]}{w[f(\\lambda_1),f(\\lambda_2)]} \\\\ u[2]= u[1] + 2[\\ln f[1]]_{xx} = 2\\left[\\ln \\left| \\begin{array}{cc} f(\\lambda_1) \u0026 f_x(\\lambda_1) \\\\ f(\\lambda_2) \u0026 f_x(\\lambda_2) \\end{array}\\right|\\right]_{xx}=2[\\ln w[f(\\lambda_1),f(\\lambda_2)]]_{xx} \\end{cases} $$其中$w[\\cdots]$是朗斯基行列式。\nN孤子解 从上面的结果可以猜测$n$孤子解的形式\n$$ \\begin{cases} \\phi[n] = \\frac{w[f(\\lambda_1),\\cdots,f(\\lambda_n), f(\\lambda)]}{w[f(\\lambda_1),\\cdots,f(\\lambda_n)]} \\\\ u[n] = 2[\\ln w[f(\\lambda_1),\\cdots,f(\\lambda_n)]]_{xx} \\end{cases} $$下面将通过归纳法证明这个式子，不过在此之前先推导一些朗斯基行列式相关的公式。\n朗斯基行列式求导 $$ w[f(\\lambda_1),\\cdots,f(\\lambda_n)]=\\left| \\begin{array}{c} f(\\lambda_1) \u0026\\cdots \u0026f^{(n-1)}(\\lambda_1) \u0026f^{(n)}(\\lambda_1) \\\\ f(\\lambda_2) \u0026\\cdots \u0026f^{(n-1)}(\\lambda_2) \u0026f^{(n)}(\\lambda_2) \\\\ \\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \\\\ f(\\lambda_n) \u0026\\cdots \u0026f^{(n-1)}(\\lambda_n) \u0026f^{(n)}(\\lambda_n) \\end{array} \\right| $$将朗斯基行列式展开为$n!$项，对每一个乘积项应用莱布尼兹法则，再按照求导作用到的位置将所得到的$n\\times n!$项分类，恢复成$n$个行列式，可以发现其中有$n-1$个行列式均为零（因为有相同的列），所以朗斯基行列式求导等于\n$$ w_x[f(\\lambda_1),\\cdots,f(\\lambda_n)]=\\left| \\begin{array}{c} f(\\lambda_1) \u0026\\cdots \u0026f^{(n-1)}(\\lambda_1) \u0026f^{(n+1)}(\\lambda_1) \\\\ f(\\lambda_2) \u0026\\cdots \u0026f^{(n-1)}(\\lambda_2) \u0026f^{(n+1)}(\\lambda_2) \\\\ \\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \\\\ f(\\lambda_n) \u0026\\cdots \u0026f^{(n-1)}(\\lambda_n) \u0026f^{(n+1)}(\\lambda_n) \\end{array} \\right| $$分块矩阵行列式 分块矩阵求行列式有如下公式\n$$ \\left| \\begin{array}{c} A \u0026 B \\\\ C \u0026 D \\end{array} \\right| = |A| |D - C A^{-1} B| $$应用到朗斯基行列式中有\n$$ \\begin{aligned} w[f(\\lambda_1),\\cdots,f(\\lambda_n), f(\\lambda_{n+1})]\u0026=\\left| \\begin{array}{c} f(\\lambda_1) \u0026\\cdots \u0026f^{(n)}(\\lambda_1) \u0026f^{(n+1)}(\\lambda_1) \\\\ f(\\lambda_2) \u0026\\cdots \u0026f^{(n)}(\\lambda_2) \u0026f^{(n+1)}(\\lambda_2)\\\\ \\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \\\\ f(\\lambda_n) \u0026\\cdots \u0026f^{(n)}(\\lambda_n) \u0026f^{(n+1)}(\\lambda_n)\\\\ f(\\lambda_{n+1}) \u0026\\cdots \u0026f^{(n)}(\\lambda_{n+1}) \u0026f^{(n+1)}(\\lambda_{n+1}) \\end{array} \\right|\\\\ \u0026=w[f(\\lambda_1),\\cdots,f(\\lambda_n)] ( f^{(n+1)}(\\lambda_{n+1}) - C(\\lambda_{n+1},n) W^{-1}(f(\\lambda_1),\\cdots,f(\\lambda_n)) B(n+1,\\lambda_{n}) ) \\end{aligned} $$$$ \\begin{aligned} w_x[f(\\lambda_1),\\cdots,f(\\lambda_n), f(\\lambda_{n+1})]\u0026=\\left| \\begin{array}{c} f(\\lambda_1) \u0026\\cdots \u0026f^{(n)}(\\lambda_1) \u0026f^{(n+2)}(\\lambda_1) \\\\ f(\\lambda_2) \u0026\\cdots \u0026f^{(n)}(\\lambda_2) \u0026f^{(n+2)}(\\lambda_2)\\\\ \\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \\\\ f(\\lambda_n) \u0026\\cdots \u0026f^{(n)}(\\lambda_n) \u0026f^{(n+2)}(\\lambda_n)\\\\ f(\\lambda_{n+1}) \u0026\\cdots \u0026f^{(n)}(\\lambda_{n+1}) \u0026f^{(n+2)}(\\lambda_{n+1}) \\end{array} \\right|\\\\ \u0026=w[f(\\lambda_1),\\cdots,f(\\lambda_n)] ( f^{(n+2)}(\\lambda_{n+1}) - C(\\lambda_{n+1},n) W^{-1}(f(\\lambda_1),\\cdots,f(\\lambda_n)) B(n+2,\\lambda_{n}) ) \\end{aligned} $$$$ \\begin{aligned} w[f(\\lambda_1),\\cdots,f(\\lambda_n), f(\\lambda)]\u0026=\\left| \\begin{array}{c} f(\\lambda_1) \u0026\\cdots \u0026f^{(n)}(\\lambda_1) \u0026f^{(n+1)}(\\lambda_1) \\\\ f(\\lambda_2) \u0026\\cdots \u0026f^{(n)}(\\lambda_2) \u0026f^{(n+1)}(\\lambda_2)\\\\ \\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \\\\ f(\\lambda_n) \u0026\\cdots \u0026f^{(n)}(\\lambda_n) \u0026f^{(n+1)}(\\lambda_n)\\\\ f(\\lambda) \u0026\\cdots \u0026f^{(n)}(\\lambda) \u0026f^{(n+1)}(\\lambda) \\end{array} \\right|\\\\ \u0026=w[f(\\lambda_1),\\cdots,f(\\lambda_n)] ( f^{(n+1)}(\\lambda) - C(\\lambda,n) W^{-1}(f(\\lambda_1),\\cdots,f(\\lambda_n)) B(n+1,\\lambda_{n}) ) \\end{aligned} $$$$ \\begin{aligned} w_x[f(\\lambda_1),\\cdots,f(\\lambda_n), f(\\lambda)]\u0026=\\left| \\begin{array}{c} f(\\lambda_1) \u0026\\cdots \u0026f^{(n)}(\\lambda_1) \u0026f^{(n+2)}(\\lambda_1) \\\\ f(\\lambda_2) \u0026\\cdots \u0026f^{(n)}(\\lambda_2) \u0026f^{(n+2)}(\\lambda_2)\\\\ \\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \\\\ f(\\lambda_n) \u0026\\cdots \u0026f^{(n)}(\\lambda_n) \u0026f^{(n+2)}(\\lambda_n)\\\\ f(\\lambda) \u0026\\cdots \u0026f^{(n)}(\\lambda) \u0026f^{(n+2)}(\\lambda) \\end{array} \\right|\\\\ \u0026=w[f(\\lambda_1),\\cdots,f(\\lambda_n)] ( f^{(n+2)}(\\lambda) - C(\\lambda,n) W^{-1}(f(\\lambda_1),\\cdots,f(\\lambda_n)) B(n+2,\\lambda_{n}) ) \\end{aligned} $$$$ \\begin{aligned} w[f(\\lambda_1),\\cdots,f(\\lambda_n), f(\\lambda_{n+1}), f(\\lambda)]\u0026=\\left| \\begin{array}{c} f(\\lambda_1) \u0026\\cdots \u0026f^{(n)}(\\lambda_1) \u0026f^{(n+1)}(\\lambda_1) \u0026f^{(n+2)}(\\lambda_1) \\\\ f(\\lambda_2) \u0026\\cdots \u0026f^{(n)}(\\lambda_2) \u0026f^{(n+1)}(\\lambda_2) \u0026f^{(n+2)}(\\lambda_2) \\\\ \\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \\\\ f(\\lambda_n) \u0026\\cdots \u0026f^{(n)}(\\lambda_n) \u0026f^{(n+1)}(\\lambda_n) \u0026f^{(n+2)}(\\lambda_n) \\\\ f(\\lambda_{n+1}) \u0026\\cdots \u0026f^{(n)}(\\lambda_{n+1}) \u0026f^{(n+1)}(\\lambda_{n+1}) \u0026f^{(n+2)}(\\lambda_{n+1}) \\\\ f(\\lambda) \u0026\\cdots \u0026f^{(n)}(\\lambda) \u0026f^{(n+1)}(\\lambda) \u0026f^{(n+2)}(\\lambda) \\end{array} \\right|\\\\ \u0026=w[f(\\lambda_1),\\cdots,f(\\lambda_n)]\\left| \\left( \\begin{matrix} f^{(n+1)}(\\lambda_{n+1}) \u0026 f^{(n+2)}(\\lambda_{n+1}) \\\\ f^{(n+1)}(\\lambda) \u0026 f^{(n+2)}(\\lambda) \\end{matrix} \\right)- \\left( \\begin{matrix} C(\\lambda_{n+1},n) \\\\ C(\\lambda,n) \\end{matrix} \\right) W^{-1}(f(\\lambda_1),\\cdots,f(\\lambda_n)) \\left( \\begin{matrix} B(n+1,\\lambda_{n}) \u0026 B(n+2,\\lambda_{n}) \\end{matrix} \\right) \\right| \\\\ \u0026=w[f(\\lambda_1),\\cdots,f(\\lambda_n)] \\left| \\begin{array}{c} f^{(n+1)}(\\lambda_{n+1}) - C(\\lambda_{n+1},n) W^{-1}(f(\\lambda_1),\\cdots,f(\\lambda_n)) B(n+1,\\lambda_{n}) \u0026 f^{(n+2)}(\\lambda_{n+1}) - C(\\lambda_{n+1},n) W^{-1}(f(\\lambda_1),\\cdots,f(\\lambda_n)) B(n+2,\\lambda_{n}) \\\\ f^{(n+1)}(\\lambda) - C(\\lambda,n) W^{-1}(f(\\lambda_1),\\cdots,f(\\lambda_n)) B(n+1,\\lambda_{n}) \u0026 f^{(n+2)}(\\lambda) - C(\\lambda,n) W^{-1}(f(\\lambda_1),\\cdots,f(\\lambda_n)) B(n+2,\\lambda_{n}) \\end{array} \\right| \\\\ \u0026= \\frac{w_x[f(\\lambda_1),\\cdots,f(\\lambda_n), f(\\lambda)]w[f(\\lambda_1),\\cdots,f(\\lambda_n), f(\\lambda_{n+1})] - w[f(\\lambda_1),\\cdots,f(\\lambda_n), f(\\lambda)] w_x[f(\\lambda_1),\\cdots,f(\\lambda_n), f(\\lambda_{n+1})]}{w[f(\\lambda_1),\\cdots,f(\\lambda_n)]} \\end{aligned} $$其中\n$$ \\begin{aligned} W(f(\\lambda_1),\\cdots,f(\\lambda_n)) \u0026 =\\left( \\begin{array}{c} f(\\lambda_1) \u0026\\cdots \u0026f^{(n-1)}(\\lambda_1) \u0026f^{(n)}(\\lambda_1) \\\\ f(\\lambda_2) \u0026\\cdots \u0026f^{(n-1)}(\\lambda_2) \u0026f^{(n)}(\\lambda_2) \\\\ \\vdots \u0026\\vdots \u0026\\vdots \u0026\\vdots \\\\ f(\\lambda_n) \u0026\\cdots \u0026f^{(n-1)}(\\lambda_n) \u0026f^{(n)}(\\lambda_n) \\end{array} \\right) \\\\ C(\\lambda_{n+1},n) \u0026= \\left( \\begin{matrix} f(\\lambda_{n+1}) \u0026\\cdots \u0026f^{(n-1)}(\\lambda_{n+1}) \u0026f^{(n)}(\\lambda_{n+1}) \\end{matrix} \\right) \\\\ C(\\lambda,n) \u0026= \\left( \\begin{matrix} f(\\lambda) \u0026\\cdots \u0026f^{(n-1)}(\\lambda) \u0026f^{(n)}(\\lambda) \\end{matrix} \\right) \\\\ B(n+1,\\lambda_{n}) \u0026= \\left( \\begin{matrix} f^{(n+1)}(\\lambda_1) \\\\ \\vdots \\\\ f^{(n+1)}(\\lambda_{n-1}) \\\\ f^{(n+1)}(\\lambda_{n}) \\end{matrix} \\right) \\\\ B(n+2,\\lambda_{n}) \u0026= \\left( \\begin{matrix} f^{(n+2)}(\\lambda_1) \\\\ \\vdots \\\\ f^{(n+2)}(\\lambda_{n-1}) \\\\ f^{(n+2)}(\\lambda_{n}) \\end{matrix} \\right) \\end{aligned} $$归纳证明 假定$n$孤子解有如下形式\n$$ \\begin{cases} \\phi[n] = \\frac{w[f(\\lambda_1),\\cdots,f(\\lambda_n), f(\\lambda)]}{w[f(\\lambda_1),\\cdots,f(\\lambda_n)]} \\\\ u[n] = 2[\\ln w[f(\\lambda_1),\\cdots,f(\\lambda_n)]]_{xx} \\end{cases} $$现在证明利用$f[n] = \\frac{w[f(\\lambda_1),\\cdots,f(\\lambda_{n}), f(\\lambda_{n+1})]}{w[f(\\lambda_1),\\cdots,f(\\lambda_{n})]}$进行达布变换后的$n+1$孤子解为\n$$ \\begin{cases} \\phi[n+1] = \\frac{w[f(\\lambda_1),\\cdots,f(\\lambda_{n+1}), f(\\lambda)]}{w[f(\\lambda_1),\\cdots,f(\\lambda_{n+1})]} \\\\ u[n+1] = 2[\\ln w[f(\\lambda_1),\\cdots,f(\\lambda_{n+1})]]_{xx} \\end{cases} $$$u[n+1]$的证明是显然的，所以下面主要关注$\\phi[n+1]$\n$$ \\begin{aligned} \u0026 \\phi[n+1] =\\phi_x[n] - \\frac{f_x[n]}{f[n]}\\phi[n] \\\\ \u0026 = \\frac{w_x[f(\\lambda_1),\\cdots,f(\\lambda_n), f(\\lambda)]w[f(\\lambda_1),\\cdots,f(\\lambda_n)] - w[f(\\lambda_1),\\cdots,f(\\lambda_n), f(\\lambda)] w_x[f(\\lambda_1),\\cdots,f(\\lambda_n)]}{w^2[f(\\lambda_1),\\cdots,f(\\lambda_n)]} \\\\ \u0026 \\quad - \\frac{w_x[f(\\lambda_1),\\cdots,f(\\lambda_n), f(\\lambda_{n+1})]w[f(\\lambda_1),\\cdots,f(\\lambda_n)] - w[f(\\lambda_1),\\cdots,f(\\lambda_n), f(\\lambda_{n+1})] w_x[f(\\lambda_1),\\cdots,f(\\lambda_n)]}{w^2[f(\\lambda_1),\\cdots,f(\\lambda_n)]} \\frac{w[f(\\lambda_1),\\cdots,f(\\lambda_{n}),f(\\lambda)]}{w[f(\\lambda_1),\\cdots,f(\\lambda_{n}),f(\\lambda_{n+1})]} \\\\ \u0026 = \\frac{w_x[f(\\lambda_1),\\cdots,f(\\lambda_n), f(\\lambda)]w[f(\\lambda_1),\\cdots,f(\\lambda_{n}),f(\\lambda_{n+1})]-w_x[f(\\lambda_1),\\cdots,f(\\lambda_n), f(\\lambda_{n+1})]w[f(\\lambda_1),\\cdots,f(\\lambda_{n}),f(\\lambda)]}{w[f(\\lambda_1),\\cdots,f(\\lambda_n)] w[f(\\lambda_1),\\cdots,f(\\lambda_{n}),f(\\lambda_{n+1})]} \\\\ \\end{aligned} $$利用上一小节证明的式子可以得到\n$$ \\phi[n+1]= \\frac{w[f(\\lambda_1),\\cdots,f(\\lambda_{n+1}), f(\\lambda)]}{w[f(\\lambda_1),\\cdots,f(\\lambda_{n+1})]} $$ 这正是我们想要的结论。\n题外话-贝克隆变换和非线性叠加 另一种形式的$n$孤子解构造可以通过贝克隆变换后的非线性叠加公式得到，非常有趣。\n定义$w$满足方程$w_t+3w_x^2+w_{xxx}=0$，对它求导可以得到$u=w_x$满足KdV方程。将上面的达布变换应用到$w$上\n$$ \\begin{cases} \\bar{u} = u + 2(\\ln f)_{xx} \\\\ (\\bar{w}=w + 2(\\ln f)_x) \\\\ f_{xx} + uf = \\lambda f \\end{cases} \\Rightarrow \\bar{w}_x-w_x=2\\frac{f_{xx}f - f^2_x}{f^2}=2\\lambda-2w_x-\\frac{1}{2}(\\bar{w}-w)^2 $$$$ \\Rightarrow \\bar{w}_x + w_x = 2\\lambda - \\frac{1}{2}(\\bar{w}-w)^2 $$达布变换后$\\bar{w}$依然满足$\\bar{w}_t+3\\bar{w}x^2+\\bar{w}{xxx}=0$，和$w$满足的方程作差得到\n$$ \\bar{w}_t - w_t + 3\\bar{w}^2_x - 3 w^2_x + \\bar{w}_{xxx} - w_{xxx} = 0 $$这两个方程允许我们从$w$得到$\\bar{w}$。\n假定我们从种子$w_0$出发通过参数为$\\lambda_1$（$\\lambda_2$）的变换得到了解$w_1$（$w_2$），然后再利用$w_1$通过参数为$\\lambda_2$（$\\lambda_1$）的变换得到了解$w_{12}$（$w_{21}$），令这两个解相等，就可以得到非线性叠加公式（也即从$w_1,w_2$出发代数叠加得到$w_{12}$）\n$$ w_{12} = w_0 + \\frac{4(\\lambda_2 - \\lambda_1)}{w_2 - w_1} $$这种叠加可以一直进行下去构造多孤子解，如图所示 可以看出，非线性叠加的参数对称化要求（$w_{21}=w_{12}$）对于这种持续的构造是必要的，因为需要不同的参数解作为种子。\n","date":"2025-04-05T17:40:49+08:00","permalink":"http://localhost:1313/slices/n-solitons-construction-of-kdv-eq/","title":"N Solitons Construction of KdV eq"},{"content":"Boltzmann 这两天看到关于希尔伯特第六问题的新闻，突然想起\u0026hellip; （多年以后，又一次刷到这条新闻的时候，Squid会想起他为做公选课视频硬描玻尔兹曼的那个下午）\n","date":"2025-03-08T17:37:49+08:00","permalink":"http://localhost:1313/slices/some-plots/","title":"Some Plots"},{"content":"basic 固体物理条目\n电动力学条目\n基础量子力学\n传播子与散射\n热力学要点\n线性响应关系整理\n微分几何条目（最早的小结，不是后来的风格，一些东西也没推完，待重制\u0026hellip;） （但怎么说呢，也许风格自由也是初心的体现吧？）\ntopic 布洛赫输运\n量子霍尔效应初步\n满足置换对称性的多体哈密顿量的$\\mathfrak{su}(n)$约化\n无杂质Peierls相变温度的多体理论计算\nFRG视角下的Efimov效应\n平均场费米超流中的重杂质相互作用\njust for fun 由配分函数发散想到\nshort notes 自旋压缩态相关背景\nmath tips 高维泰勒展开\n拉格朗日乘子法\n勒让德变换\n留数定理\n雅可比行列式\n","date":"2025-01-18T15:13:00+08:00","image":"http://localhost:1313/slices/collections-of-notes/notes_post_pic_hu440123188582958321.jpg","permalink":"http://localhost:1313/slices/collections-of-notes/","title":"Collections of Notes"},{"content":"最近了解到交易中破产概率的计算，觉得很有意思，也比较简单，记录一下。\n假定一个交易者胜率为$p$，每次止盈止损额度均为$s$，总亏损上限为$Ns$，那么他在市场上的破产概率$P_{b,N}$为\n$$ P_{b,N} = \\begin{cases} \u0026 \\left(\\frac{1-p}{p}\\right)^N \u0026 p\\geq 0.5 \\\\ \u0026 1 \u0026 p\\leq 0.5 \\end{cases}. $$推导 假定交易者A和B进行交易，每次止盈止损额度均为$s$，A、B的总亏损上限分别为$Ns,Ms$，A的胜率为$p$。计算足够次数交易后，A把钱全部输给B的概率$P_{b,N}^M$，然后令$M\\to\\infty$得到$P_b$。\n设A在拥有亏损额度$ns$时，破产概率为$P_{b,n}^M$。交易一次后，A有概率$p$拥有$(n+1)s$亏损额度，概率$(1-p)$拥有$(n-1)s$亏损额度，于是\n$$ P_{b,n}^M = (1-p)P_{b,n-1}^M + pP_{b,n+1}^M \\Rightarrow (1-p)(P_{b,n}^M - P_{b,n-1}^M) = p (P_{b,n+1}^M - P_{b,n}^M), $$$$ \\Rightarrow P^M_{b,n+1} - P^M_{b,n} = C_0\\left(\\frac{1-p}{p}\\right)^n, $$其中$C_0=P^M_{b,1}-P^M_{b,0}$为常数。求和可以得到\n$$ P^M_{b,n}-P^M_{b,0}= \\begin{cases} \u0026 C_0 \\frac{1-(1/p-1)^n}{2-1/p}, \u0026 p\\neq 0.5 \\\\ \u0026 n C_0, \u0026 p=0.5 \\end{cases}. $$$$ C_0 = \\begin{cases} \u0026 -\\frac{2-1/p}{1-(1/p-1)^{N+M}}, \u0026 p\\neq 0.5 \\\\ \u0026 -\\frac{1}{N+M}, \u0026 p=0.5 \\end{cases}. $$于是\n$$ P^M_{b,N} = \\begin{cases} \u0026 1 - \\frac{1-(1/p-1)^N}{1-(1/p-1)^{N+M}} = \\frac{(1/p-1)^N-(1/p-1)^{N+M}}{1-(1/p-1)^{N+M}}, \u0026 p\\neq 0.5 \\\\ \u0026 1 - \\frac{N}{N+M} = \\frac{M}{N+M}, \u0026 p=0.5 \\end{cases}. $$取$M\\to\\infty$，\n$$ P_{b,N} = \\lim_{M\\to\\infty} P^M_{b,N} = \\begin{cases} \u0026 \\lim_{M\\to\\infty} \\frac{(1/p-1)^N-(1/p-1)^{N+M}}{1-(1/p-1)^{N+M}}= \\begin{cases} \u0026 1, \u0026p \u003c 0.5 \\\\ \u0026 \\left(\\frac{1-p}{p}\\right)^N, \u0026p \u003e 0.5 \\end{cases}, \u0026 p\\neq 0.5\\\\ \u0026 \\lim_{M\\to\\infty} \\frac{M}{N+M}=1 \u0026 p=0.5 \\end{cases} $$这就证明了开头的结论。\n","date":"2025-01-05T18:32:40+08:00","permalink":"http://localhost:1313/slices/bankrupt-probability/","title":"Bankrupt Probability"},{"content":"回忆火车 库洛米 小熊猫 ","date":"2024-06-02T17:38:50+08:00","permalink":"http://localhost:1313/slices/some-toys/","title":"Some Toys"},{"content":"Mathematica 球谐函数积分化为CG系数（AngleIntegratedToCGPackage）\n利用上面的包AngleIntegratedToCGPackage计算角向矩阵元（重复这篇文章补充材料中的S15式）\n$\\braket{bar|ket}$的内积直积化简（QuantumSimplificationPackage：去掉运算符的保护，重新定义化简规则）\n利用上面的包QuantumSimplificationPackage计算哈密顿量矩阵元（重复这篇文章补充材料中的S1小结）\n利用一些技巧得到节点为变量时B样条的显式表达式（mma中好像只能直接得到节点为常数时B样条表达式）\nSympy 表达式中途展开+符号变量替换求复杂色散关系展开式（重复这篇文章中的色散关系）\n","date":"2024-04-30T10:52:28+08:00","permalink":"http://localhost:1313/slices/examples-of-symbolic-calc/","title":"Examples of Symbolic Calc"}]